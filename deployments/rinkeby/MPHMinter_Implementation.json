{
  "address": "0xfdB60fF449a73a02681667625819d1F4FC247641",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "string",
          "name": "paramName",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "newValue",
          "type": "address"
        }
      ],
      "name": "ESetParamAddress",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "depositorReward",
          "type": "uint256"
        }
      ],
      "name": "MintDepositorReward",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "funderReward",
          "type": "uint256"
        }
      ],
      "name": "MintFunderReward",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "previousAdminRole",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "newAdminRole",
          "type": "bytes32"
        }
      ],
      "name": "RoleAdminChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "RoleGranted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "RoleRevoked",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "takeBackAmount",
          "type": "uint256"
        }
      ],
      "name": "TakeBackDepositorReward",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "DEFAULT_ADMIN_ROLE",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "WHITELISTED_POOL_ROLE",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "WHITELISTER_ROLE",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "internalType": "uint64",
          "name": "depositID",
          "type": "uint64"
        }
      ],
      "name": "createVestForDeposit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "devWallet",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "fundingID",
          "type": "uint64"
        },
        {
          "internalType": "uint256",
          "name": "interestAmount",
          "type": "uint256"
        }
      ],
      "name": "distributeFundingRewards",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        }
      ],
      "name": "getRoleAdmin",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "govTreasury",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "grantRole",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "hasRole",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_mph",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_govTreasury",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_devWallet",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_issuanceModel",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_vesting",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_vesting02",
          "type": "address"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "issuanceModel",
      "outputs": [
        {
          "internalType": "contract IMPHIssuanceModel",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "depositAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "depositPeriodInSeconds",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "interestAmount",
          "type": "uint256"
        }
      ],
      "name": "mintDepositorReward",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "depositAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "fundingCreationTimestamp",
          "type": "uint256"
        },
        {
          "internalType": "uint64",
          "name": "maturationTimestamp",
          "type": "uint64"
        },
        {
          "internalType": "uint256",
          "name": "interestPayoutAmount",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "early",
          "type": "bool"
        }
      ],
      "name": "mintFunderReward",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "mintVested",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "mintedAmount",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "mph",
      "outputs": [
        {
          "internalType": "contract MPHToken",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "renounceRole",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "revokeRole",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newValue",
          "type": "address"
        }
      ],
      "name": "setDevWallet",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newValue",
          "type": "address"
        }
      ],
      "name": "setGovTreasury",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newValue",
          "type": "address"
        }
      ],
      "name": "setIssuanceModel",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newValue",
          "type": "address"
        }
      ],
      "name": "setMPHTokenOwner",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "setMPHTokenOwnerToZero",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newValue",
          "type": "address"
        }
      ],
      "name": "setVesting",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newValue",
          "type": "address"
        }
      ],
      "name": "setVesting02",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "mintMPHAmount",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "early",
          "type": "bool"
        }
      ],
      "name": "takeBackDepositorReward",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "depositID",
          "type": "uint64"
        },
        {
          "internalType": "uint256",
          "name": "currentDepositAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "depositAmount",
          "type": "uint256"
        }
      ],
      "name": "updateVestForDeposit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "vesting",
      "outputs": [
        {
          "internalType": "contract Vesting",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "vesting02",
      "outputs": [
        {
          "internalType": "contract Vesting02",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x9297bfc6d3f501b87d3380bfd754654770308fe043831048dc61bec8488e9d71",
  "receipt": {
    "to": null,
    "from": "0xc0FcF8403e10B65f1D18f1B81b093004B1127275",
    "contractAddress": "0xfdB60fF449a73a02681667625819d1F4FC247641",
    "transactionIndex": 3,
    "gasUsed": "2520965",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xb9132e817da9ce4f5f35a892376460ff2bff4c231ab36841df136655008d4843",
    "transactionHash": "0x9297bfc6d3f501b87d3380bfd754654770308fe043831048dc61bec8488e9d71",
    "logs": [],
    "blockNumber": 8694953,
    "cumulativeGasUsed": "3073992",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "e60ae8ce476666259c0e591d71d287b8",
  "metadata": "{\"compiler\":{\"version\":\"0.8.3+commit.8d00100c\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"paramName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"ESetParamAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositorReward\",\"type\":\"uint256\"}],\"name\":\"MintDepositorReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"funderReward\",\"type\":\"uint256\"}],\"name\":\"MintFunderReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"takeBackAmount\",\"type\":\"uint256\"}],\"name\":\"TakeBackDepositorReward\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WHITELISTED_POOL_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WHITELISTER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"depositID\",\"type\":\"uint64\"}],\"name\":\"createVestForDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"fundingID\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"interestAmount\",\"type\":\"uint256\"}],\"name\":\"distributeFundingRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"govTreasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mph\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_govTreasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_devWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_issuanceModel\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vesting\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vesting02\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"issuanceModel\",\"outputs\":[{\"internalType\":\"contract IMPHIssuanceModel\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositPeriodInSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestAmount\",\"type\":\"uint256\"}],\"name\":\"mintDepositorReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fundingCreationTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"maturationTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"interestPayoutAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"early\",\"type\":\"bool\"}],\"name\":\"mintFunderReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintVested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mph\",\"outputs\":[{\"internalType\":\"contract MPHToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"setDevWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"setGovTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"setIssuanceModel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"setMPHTokenOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setMPHTokenOwnerToZero\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"setVesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"setVesting02\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"mintMPHAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"early\",\"type\":\"bool\"}],\"name\":\"takeBackDepositorReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"depositID\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"currentDepositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"}],\"name\":\"updateVestForDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vesting\",\"outputs\":[{\"internalType\":\"contract Vesting\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vesting02\",\"outputs\":[{\"internalType\":\"contract Vesting02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getRoleAdmin(bytes32)\":{\"details\":\"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.\"},\"grantRole(bytes32,address)\":{\"details\":\"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.\"},\"hasRole(bytes32,address)\":{\"details\":\"Returns `true` if `account` has been granted `role`.\"},\"mintDepositorReward(address,uint256,uint256,uint256)\":{\"params\":{\"depositAmount\":\"The deposit amount in the pool's stablecoins\",\"depositPeriodInSeconds\":\"The deposit's lock period in seconds\",\"interestAmount\":\"The deposit's fixed-rate interest amount in the pool's stablecoins\",\"to\":\"The depositor\"},\"returns\":{\"_0\":\"depositorReward The MPH amount to mint to the depositor\"}},\"mintFunderReward(address,uint256,uint256,uint64,uint256,bool)\":{\"params\":{\"depositAmount\":\"The deposit amount in the pool's stablecoins\",\"early\":\"True if the deposit is withdrawn early, false if the deposit is mature\",\"fundingCreationTimestamp\":\"The timestamp of the funding's creation, in seconds\",\"interestPayoutAmount\":\"The interest payout amount to the funder, in the pool's stablecoins. Includes the interest from other funded deposits.\",\"maturationTimestamp\":\"The maturation timestamp of the deposit, in seconds\",\"to\":\"The funder\"},\"returns\":{\"_0\":\"funderReward The MPH amount to mint to the funder\"}},\"renounceRole(bytes32,address)\":{\"details\":\"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.\"},\"revokeRole(bytes32,address)\":{\"details\":\"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.\"},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"},\"takeBackDepositorReward(address,uint256,bool)\":{\"params\":{\"early\":\"True if the deposit is withdrawn early, false if the deposit is mature\",\"from\":\"The depositor\",\"mintMPHAmount\":\"The MPH amount originally minted to the depositor as reward\"},\"returns\":{\"_0\":\"takeBackAmount The MPH amount to take back from the depositor\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"createVestForDeposit(address,uint64)\":{\"notice\":\"v3 functions\"},\"mintDepositorReward(address,uint256,uint256,uint256)\":{\"notice\":\"Mints the MPH reward to a depositor upon deposit.\"},\"mintFunderReward(address,uint256,uint256,uint64,uint256,bool)\":{\"notice\":\"Mints the MPH reward to a deficit funder upon withdrawal of an underlying deposit.\"},\"mph()\":{\"notice\":\"External contracts\"},\"setGovTreasury(address)\":{\"notice\":\"Param setters\"},\"setVesting02(address)\":{\"notice\":\"Param setters\"},\"takeBackDepositorReward(address,uint256,bool)\":{\"notice\":\"Takes back MPH from depositor upon withdrawal. If takeBackAmount > devReward + govReward, the extra MPH should be burnt.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/rewards/MPHMinter.sol\":\"MPHMinter\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../utils/StringsUpgradeable.sol\\\";\\nimport \\\"../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControlUpgradeable {\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n    function grantRole(bytes32 role, address account) external;\\n    function revokeRole(bytes32 role, address account) external;\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\\n    function __AccessControl_init() internal initializer {\\n        __Context_init_unchained();\\n        __ERC165_init_unchained();\\n        __AccessControl_init_unchained();\\n    }\\n\\n    function __AccessControl_init_unchained() internal initializer {\\n    }\\n    struct RoleData {\\n        mapping (address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping (bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, _msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view {\\n        if(!hasRole(role, account)) {\\n            revert(string(abi.encodePacked(\\n                \\\"AccessControl: account \\\",\\n                StringsUpgradeable.toHexString(uint160(account), 20),\\n                \\\" is missing role \\\",\\n                StringsUpgradeable.toHexString(uint256(role), 32)\\n            )));\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x719f71989e630280a6902f857ef2b038d761ef2d0d51611f9da463be6c7c4be5\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0xc68cad93ce702131a09334e8705d4af062278defa99627a2c94685fb96ff8cc4\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary ClonesUpgradeable {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer) internal pure returns (address predicted) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt) internal view returns (address predicted) {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\",\"keccak256\":\"0x4dc6dad1fc53f05013cffc92c2c39ec795bfca13776488d68b9f8cedd1464dd3\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x67d2f282a9678e58e878a0b774041ba7a01e2740a262aea97a3f681339914713\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal initializer {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal initializer {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x89fa60d14355f7ae06af11e28fce2bb90c5c6186645d681a30e1b36234a4c210\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\\n\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n}\\n\",\"keccak256\":\"0xd841c561258151c3c22f05feb68c702fc414b112606bd72b848e8a65af128c30\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\\n}\\n\",\"keccak256\":\"0xa22cd3d499a04af4dbcc1b15877b69b611004ff02a2ab121e42226a6b6a88ab9\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURIUpgradeable is IERC1155Upgradeable {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x6d0b5e3282b9f7683eb822a01bd5351d01bd9225cd8153e366c9a54e89213165\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"./extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The defaut value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\\n        __Context_init_unchained();\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        _approve(sender, _msgSender(), currentAllowance - amount);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[sender] = senderBalance - amount;\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _balances[account] = accountBalance - amount;\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n    uint256[45] private __gap;\\n}\\n\",\"keccak256\":\"0x9c2d7425f3343ea340d6ea67e9d90109d4d846bb013c2572096ec88c9e74946b\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x8d4a0f2b5b760b5e2c19ed3c108d83897a4dfd5bfed97a93867918df19191e5e\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20Upgradeable.sol\\\";\\nimport \\\"../../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\\n    function __ERC20Burnable_init() internal initializer {\\n        __Context_init_unchained();\\n        __ERC20Burnable_init_unchained();\\n    }\\n\\n    function __ERC20Burnable_init_unchained() internal initializer {\\n    }\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        uint256 currentAllowance = allowance(account, _msgSender());\\n        require(currentAllowance >= amount, \\\"ERC20: burn amount exceeds allowance\\\");\\n        _approve(account, _msgSender(), currentAllowance - amount);\\n        _burn(account, amount);\\n    }\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xf843e6be146e6ea9334ae506376a517968aeee7807fdcbc10a8e13bcdaebf546\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x6795c369a4eefa78468e38966f7851fbc2dda5e5b9ccd3fa2b45970e2e4d3abd\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721Upgradeable.sol\\\";\\nimport \\\"./IERC721ReceiverUpgradeable.sol\\\";\\nimport \\\"./extensions/IERC721MetadataUpgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../utils/StringsUpgradeable.sol\\\";\\nimport \\\"../../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\\n    using AddressUpgradeable for address;\\n    using StringsUpgradeable for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping (uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping (address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping (uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    function __ERC721_init(string memory name_, string memory symbol_) internal initializer {\\n        __Context_init_unchained();\\n        __ERC165_init_unchained();\\n        __ERC721_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal initializer {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\\n        return interfaceId == type(IERC721Upgradeable).interfaceId\\n            || interfaceId == type(IERC721MetadataUpgradeable).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0\\n            ? string(abi.encodePacked(baseURI, tokenId.toString()))\\n            : '';\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. Empty by default, can be overriden\\n     * in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _mint(to, tokenId);\\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\\n        private returns (bool)\\n    {\\n        if (to.isContract()) {\\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721ReceiverUpgradeable(to).onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    // solhint-disable-next-line no-inline-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\\n    uint256[44] private __gap;\\n}\\n\",\"keccak256\":\"0x2ab92ebd3f4d4d85f30b39bd678ec3489e00aadd0a432c7a0ffa98adc2799004\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721ReceiverUpgradeable {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0x33620beff0655c5e728a72fff76fb6ce2dc32fc6b61eb8e435b12ed1adf31525\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n      * - `from` cannot be the zero address.\\n      * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\",\"keccak256\":\"0x9ef7f2874f4a491f253a81eb4c5b9a7b6467a287aa0c32ac3dd684260a3cd7ad\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC721Upgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev ERC721 token with storage based token URI management.\\n */\\nabstract contract ERC721URIStorageUpgradeable is Initializable, ERC721Upgradeable {\\n    function __ERC721URIStorage_init() internal initializer {\\n        __Context_init_unchained();\\n        __ERC165_init_unchained();\\n        __ERC721URIStorage_init_unchained();\\n    }\\n\\n    function __ERC721URIStorage_init_unchained() internal initializer {\\n    }\\n    using StringsUpgradeable for uint256;\\n\\n    // Optional mapping for token URIs\\n    mapping (uint256 => string) private _tokenURIs;\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721URIStorage: URI query for nonexistent token\\\");\\n\\n        string memory _tokenURI = _tokenURIs[tokenId];\\n        string memory base = _baseURI();\\n\\n        // If there is no base URI, return the token URI.\\n        if (bytes(base).length == 0) {\\n            return _tokenURI;\\n        }\\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\\n        if (bytes(_tokenURI).length > 0) {\\n            return string(abi.encodePacked(base, _tokenURI));\\n        }\\n\\n        return super.tokenURI(tokenId);\\n    }\\n\\n    /**\\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\\n        require(_exists(tokenId), \\\"ERC721URIStorage: URI set of nonexistent token\\\");\\n        _tokenURIs[tokenId] = _tokenURI;\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual override {\\n        super._burn(tokenId);\\n\\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\\n            delete _tokenURIs[tokenId];\\n        }\\n    }\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x2635a6f67529b35307754379ae59fcdf274286e73f220f1bff67038a0acf1a13\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Upgradeable.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x64581a092c059ab0cb74f473545e379b8a88f36a6a57f805515ef8c6ae061847\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5642ae1d6b33c5c0b71a8412c6c64cbcf2468b84a002bee3e33cdb5644d25cdb\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x8e9eb503de1189f50c5f16fef327da310b11898d6b9ab3ca937df07c35233b9e\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/MulticallUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AddressUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides a function to batch together multiple calls in a single external call.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract MulticallUpgradeable is Initializable {\\n    function __Multicall_init() internal initializer {\\n        __Multicall_init_unchained();\\n    }\\n\\n    function __Multicall_init_unchained() internal initializer {\\n    }\\n    /**\\n    * @dev Receives and executes a batch of function calls on this contract.\\n    */\\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for (uint i = 0; i < data.length; i++) {\\n            results[i] = _functionDelegateCall(address(this), data[i]);\\n        }\\n        return results;\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\\n        require(AddressUpgradeable.isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x9486e7997aa571a043ddfc2bc0826dc48b0ea37dd02d2452db275e84c8eabd12\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    bytes16 private constant alphabet = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = alphabet[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n}\\n\",\"keccak256\":\"0x6964377da5c19ade6b3e96bae0c0e82494d518af70cf12d2cdb3276f78fb3d85\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\n    function __ERC165_init() internal initializer {\\n        __ERC165_init_unchained();\\n    }\\n\\n    function __ERC165_init_unchained() internal initializer {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\\n    }\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x17c9c5d2d6b56527215ee7b3da6dde66b6f23f1b3d5c66cc436e753ef349a97a\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x1c4860acd323e34a67b3e97faab9aaa55fe8e92b1dcf08b5f47f3468d58ce75c\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary MathUpgradeable {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\",\"keccak256\":\"0x97ae7d1909acff532e532ac63455c5222dae87c2737aefdce3db9684fd8ab93f\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCastUpgradeable {\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value < 2**128, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value < 2**64, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value < 2**32, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value < 2**16, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value < 2**8, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= -2**127 && value < 2**127, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= -2**63 && value < 2**63, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= -2**31 && value < 2**31, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= -2**15 && value < 2**15, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= -2**7 && value < 2**7, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        require(value < 2**255, \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0xc683c1c91d9e029d6a58c35dbd83762805fe8eb328e2530e3628adf72d63167d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The defaut value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        _approve(sender, _msgSender(), currentAllowance - amount);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[sender] = senderBalance - amount;\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _balances[account] = accountBalance - amount;\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\",\"keccak256\":\"0xfeccdcbf67b2006a715e5af1a4c7556004d95b2806552b5cc54e46e8eb7e887b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xf8e8d118a7a8b2e134181f7da655f6266aa3a0f9134b2605747139fcb0c5d835\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x83fe24f5c04a56091e50f4a345ff504c8bff658a76d4c43b16878c8f940c53b2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x069b2631bb5b5193a58ccf7a06266c7361bd2c20095667af4402817605627f45\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xf930d2df426bfcfc1f7415be724f04081c96f4fb9ec8d0e3a521c07692dface0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        // Divide the signature in r, s and v variables\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n        } else if (signature.length == 64) {\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                let vs := mload(add(signature, 0x40))\\n                r := mload(add(signature, 0x20))\\n                s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n                v := add(shr(255, vs), 27)\\n            }\\n        } else {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n\\n        return recover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (282): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \\\"ECDSA: invalid signature 's' value\\\");\\n        require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\",\"keccak256\":\"0x2b7a01bbc90040fd4a48bc143ac5a192da3b9bfc559ac08a78eaca40bf49e436\",\"license\":\"MIT\"},\"contracts/DInterest.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.3;\\n\\nimport {ERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport {SafeERC20} from \\\"./libs/SafeERC20.sol\\\";\\nimport {\\n    ReentrancyGuardUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\nimport {\\n    AddressUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport {\\n    OwnableUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport {\\n    MulticallUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/utils/MulticallUpgradeable.sol\\\";\\nimport {IMoneyMarket} from \\\"./moneymarkets/IMoneyMarket.sol\\\";\\nimport {IFeeModel} from \\\"./models/fee/IFeeModel.sol\\\";\\nimport {IInterestModel} from \\\"./models/interest/IInterestModel.sol\\\";\\nimport {NFT} from \\\"./tokens/NFT.sol\\\";\\nimport {FundingMultitoken} from \\\"./tokens/FundingMultitoken.sol\\\";\\nimport {MPHMinter} from \\\"./rewards/MPHMinter.sol\\\";\\nimport {IInterestOracle} from \\\"./models/interest-oracle/IInterestOracle.sol\\\";\\nimport {DecMath} from \\\"./libs/DecMath.sol\\\";\\nimport {Rescuable} from \\\"./libs/Rescuable.sol\\\";\\nimport {Sponsorable} from \\\"./libs/Sponsorable.sol\\\";\\nimport {console} from \\\"hardhat/console.sol\\\";\\n\\n/**\\n    @title DeLorean Interest -- It's coming back from the future!\\n    @author Zefram Lou\\n    @notice The main pool contract for fixed-rate deposits\\n    @dev The contract to interact with for most actions\\n */\\ncontract DInterest is\\n    ReentrancyGuardUpgradeable,\\n    OwnableUpgradeable,\\n    Rescuable,\\n    MulticallUpgradeable,\\n    Sponsorable\\n{\\n    using SafeERC20 for ERC20;\\n    using AddressUpgradeable for address;\\n    using DecMath for uint256;\\n\\n    // Constants\\n    uint256 internal constant PRECISION = 10**18;\\n    /**\\n        @dev used for sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex\\n     */\\n    uint256 internal constant EXTRA_PRECISION = 10**27;\\n    /**\\n        @dev used for funding.principalPerToken\\n     */\\n    uint256 internal constant ULTRA_PRECISION = 2**128;\\n\\n    // User deposit data\\n    // Each deposit has an ID used in the depositNFT, which is equal to its index in `deposits` plus 1\\n    struct Deposit {\\n        uint256 virtualTokenTotalSupply; // depositAmount + interestAmount, behaves like a zero coupon bond\\n        uint256 interestRate; // interestAmount = interestRate * depositAmount\\n        uint256 feeRate; // feeAmount = feeRate * depositAmount\\n        uint256 averageRecordedIncomeIndex; // Average income index at time of deposit, used for computing deposit surplus\\n        uint64 maturationTimestamp; // Unix timestamp after which the deposit may be withdrawn, in seconds\\n        uint64 fundingID; // The ID of the associated Funding struct. 0 if not funded.\\n    }\\n    Deposit[] internal deposits;\\n\\n    // Funding data\\n    // Each funding has an ID used in the fundingMultitoken, which is equal to its index in `fundingList` plus 1\\n    struct Funding {\\n        uint64 depositID; // The ID of the associated Deposit struct.\\n        uint256 recordedMoneyMarketIncomeIndex; // the income index at the last update (creation or withdrawal)\\n        uint256 principalPerToken; // The amount of stablecoins that's earning interest for you per funding token you own. Scaled to 18 decimals regardless of stablecoin decimals.\\n    }\\n    Funding[] internal fundingList;\\n    // the sum of (recordedFundedPrincipalAmount / recordedMoneyMarketIncomeIndex) of all fundings\\n    uint256 public sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex;\\n\\n    // Params\\n    /**\\n        @dev Maximum deposit period, in seconds\\n     */\\n    uint64 public MaxDepositPeriod;\\n    /**\\n        @dev Minimum deposit amount, in stablecoins\\n     */\\n    uint256 public MinDepositAmount;\\n\\n    // Global variables\\n    uint256 public totalDeposit;\\n    uint256 public totalInterestOwed;\\n    uint256 public totalFeeOwed;\\n    uint256 public totalFundedPrincipalAmount;\\n\\n    // External smart contracts\\n    IMoneyMarket public moneyMarket;\\n    ERC20 public stablecoin;\\n    IFeeModel public feeModel;\\n    IInterestModel public interestModel;\\n    IInterestOracle public interestOracle;\\n    NFT public depositNFT;\\n    FundingMultitoken public fundingMultitoken;\\n    MPHMinter public mphMinter;\\n\\n    // Events\\n    event EDeposit(\\n        address indexed sender,\\n        uint256 indexed depositID,\\n        uint256 depositAmount,\\n        uint256 interestAmount,\\n        uint256 feeAmount,\\n        uint64 maturationTimestamp\\n    );\\n    event ETopupDeposit(\\n        address indexed sender,\\n        uint64 indexed depositID,\\n        uint256 depositAmount,\\n        uint256 interestAmount,\\n        uint256 feeAmount\\n    );\\n    event ERolloverDeposit(\\n        address indexed sender,\\n        uint64 indexed depositID,\\n        uint64 indexed newDepositID\\n    );\\n    event EWithdraw(\\n        address indexed sender,\\n        uint256 indexed depositID,\\n        bool indexed early,\\n        uint256 virtualTokenAmount,\\n        uint256 feeAmount\\n    );\\n    event EFund(\\n        address indexed sender,\\n        uint64 indexed fundingID,\\n        uint256 fundAmount,\\n        uint256 tokenAmount\\n    );\\n    event EPayFundingInterest(\\n        uint256 indexed fundingID,\\n        uint256 interestAmount,\\n        uint256 refundAmount\\n    );\\n    event ESetParamAddress(\\n        address indexed sender,\\n        string indexed paramName,\\n        address newValue\\n    );\\n    event ESetParamUint(\\n        address indexed sender,\\n        string indexed paramName,\\n        uint256 newValue\\n    );\\n\\n    function __DInterest_init(\\n        uint64 _MaxDepositPeriod,\\n        uint256 _MinDepositAmount,\\n        address _moneyMarket,\\n        address _stablecoin,\\n        address _feeModel,\\n        address _interestModel,\\n        address _interestOracle,\\n        address _depositNFT,\\n        address _fundingMultitoken,\\n        address _mphMinter\\n    ) internal initializer {\\n        __ReentrancyGuard_init();\\n        __Ownable_init();\\n\\n        moneyMarket = IMoneyMarket(_moneyMarket);\\n        stablecoin = ERC20(_stablecoin);\\n        feeModel = IFeeModel(_feeModel);\\n        interestModel = IInterestModel(_interestModel);\\n        interestOracle = IInterestOracle(_interestOracle);\\n        depositNFT = NFT(_depositNFT);\\n        fundingMultitoken = FundingMultitoken(_fundingMultitoken);\\n        mphMinter = MPHMinter(_mphMinter);\\n        MaxDepositPeriod = _MaxDepositPeriod;\\n        MinDepositAmount = _MinDepositAmount;\\n    }\\n\\n    /**\\n        @param _MaxDepositPeriod The maximum deposit period, in seconds\\n        @param _MinDepositAmount The minimum deposit amount, in stablecoins\\n        @param _moneyMarket Address of IMoneyMarket that's used for generating interest (owner must be set to this DInterest contract)\\n        @param _stablecoin Address of the stablecoin used to store funds\\n        @param _feeModel Address of the FeeModel contract that determines how fees are charged\\n        @param _interestModel Address of the InterestModel contract that determines how much interest to offer\\n        @param _interestOracle Address of the InterestOracle contract that provides the average interest rate\\n        @param _depositNFT Address of the NFT representing ownership of deposits (owner must be set to this DInterest contract)\\n        @param _fundingMultitoken Address of the ERC1155 multitoken representing ownership of fundings (this DInterest contract must have the minter-burner role)\\n        @param _mphMinter Address of the contract for handling minting MPH to users\\n     */\\n    function initialize(\\n        uint64 _MaxDepositPeriod,\\n        uint256 _MinDepositAmount,\\n        address _moneyMarket,\\n        address _stablecoin,\\n        address _feeModel,\\n        address _interestModel,\\n        address _interestOracle,\\n        address _depositNFT,\\n        address _fundingMultitoken,\\n        address _mphMinter\\n    ) external virtual initializer {\\n        __DInterest_init(\\n            _MaxDepositPeriod,\\n            _MinDepositAmount,\\n            _moneyMarket,\\n            _stablecoin,\\n            _feeModel,\\n            _interestModel,\\n            _interestOracle,\\n            _depositNFT,\\n            _fundingMultitoken,\\n            _mphMinter\\n        );\\n    }\\n\\n    /**\\n        Public action functions\\n     */\\n\\n    /**\\n        @notice Create a deposit using `depositAmount` stablecoin that matures at timestamp `maturationTimestamp`.\\n        @dev The ERC-721 NFT representing deposit ownership is given to msg.sender\\n        @param depositAmount The amount of deposit, in stablecoin\\n        @param maturationTimestamp The Unix timestamp of maturation, in seconds\\n        @return depositID The ID of the created deposit\\n        @return interestAmount The amount of fixed-rate interest\\n     */\\n    function deposit(uint256 depositAmount, uint64 maturationTimestamp)\\n        external\\n        nonReentrant\\n        returns (uint64 depositID, uint256 interestAmount)\\n    {\\n        return _deposit(msg.sender, depositAmount, maturationTimestamp, false);\\n    }\\n\\n    /**\\n        @notice Add `depositAmount` stablecoin to the existing deposit with ID `depositID`.\\n        @dev The interest rate for the topped up funds will be the current oracle rate.\\n        @param depositID The deposit to top up\\n        @param depositAmount The amount to top up, in stablecoin\\n        @return interestAmount The amount of interest that will be earned by the topped up funds at maturation\\n     */\\n    function topupDeposit(uint64 depositID, uint256 depositAmount)\\n        external\\n        nonReentrant\\n        returns (uint256 interestAmount)\\n    {\\n        return _topupDeposit(msg.sender, depositID, depositAmount);\\n    }\\n\\n    /**\\n        @notice Withdraw all funds from deposit with ID `depositID` and use them\\n                to create a new deposit that matures at time `maturationTimestamp`\\n        @param depositID The deposit to roll over\\n        @param maturationTimestamp The Unix timestamp of the new deposit, in seconds\\n        @return newDepositID The ID of the new deposit\\n     */\\n    function rolloverDeposit(uint64 depositID, uint64 maturationTimestamp)\\n        external\\n        nonReentrant\\n        returns (uint256 newDepositID, uint256 interestAmount)\\n    {\\n        return _rolloverDeposit(msg.sender, depositID, maturationTimestamp);\\n    }\\n\\n    /**\\n        @notice Withdraws funds from the deposit with ID `depositID`.\\n        @dev Virtual tokens behave like zero coupon bonds, after maturation withdrawing 1 virtual token\\n             yields 1 stablecoin. The total supply is given by deposit.virtualTokenTotalSupply\\n        @param depositID the deposit to withdraw from\\n        @param virtualTokenAmount the amount of virtual tokens to withdraw\\n        @param early True if intend to withdraw before maturation, false otherwise\\n        @return withdrawnStablecoinAmount the amount of stablecoins withdrawn\\n     */\\n    function withdraw(\\n        uint64 depositID,\\n        uint256 virtualTokenAmount,\\n        bool early\\n    ) external nonReentrant returns (uint256 withdrawnStablecoinAmount) {\\n        return\\n            _withdraw(msg.sender, depositID, virtualTokenAmount, early, false);\\n    }\\n\\n    /**\\n        @notice Funds the fixed-rate interest of the deposit with ID `depositID`.\\n                In exchange, the funder receives the future floating-rate interest\\n                generated by the portion of the deposit whose interest was funded.\\n        @dev The sender receives ERC-1155 multitokens (fundingMultitoken) representing\\n             their floating-rate bonds.\\n        @param depositID The deposit whose fixed-rate interest will be funded\\n        @param fundAmount The amount of fixed-rate interest to fund.\\n                          If it exceeds surplusOfDeposit(depositID), it will be set to\\n                          the surplus value instead.\\n        @param fundingID The ID of the fundingMultitoken the sender received\\n     */\\n    function fund(uint64 depositID, uint256 fundAmount)\\n        external\\n        nonReentrant\\n        returns (uint64 fundingID)\\n    {\\n        return _fund(msg.sender, depositID, fundAmount);\\n    }\\n\\n    /**\\n        @notice Distributes the floating-rate interest accrued by a deposit to the\\n                floating-rate bond holders.\\n        @param fundingID The ID of the floating-rate bond\\n        @return interestAmount The amount of interest distributed, in stablecoins\\n     */\\n    function payInterestToFunders(uint64 fundingID)\\n        external\\n        nonReentrant\\n        returns (uint256 interestAmount)\\n    {\\n        return _payInterestToFunders(fundingID);\\n    }\\n\\n    /**\\n        Sponsored action functions\\n     */\\n\\n    function sponsoredDeposit(\\n        uint256 depositAmount,\\n        uint64 maturationTimestamp,\\n        Sponsorship calldata sponsorship\\n    )\\n        external\\n        nonReentrant\\n        sponsored(\\n            sponsorship,\\n            this.sponsoredDeposit.selector,\\n            abi.encode(depositAmount, maturationTimestamp)\\n        )\\n        returns (uint64 depositID, uint256 interestAmount)\\n    {\\n        return\\n            _deposit(\\n                sponsorship.sender,\\n                depositAmount,\\n                maturationTimestamp,\\n                false\\n            );\\n    }\\n\\n    function sponsoredTopupDeposit(\\n        uint64 depositID,\\n        uint256 depositAmount,\\n        Sponsorship calldata sponsorship\\n    )\\n        external\\n        nonReentrant\\n        sponsored(\\n            sponsorship,\\n            this.sponsoredTopupDeposit.selector,\\n            abi.encode(depositID, depositAmount)\\n        )\\n        returns (uint256 interestAmount)\\n    {\\n        return _topupDeposit(sponsorship.sender, depositID, depositAmount);\\n    }\\n\\n    function sponsoredRolloverDeposit(\\n        uint64 depositID,\\n        uint64 maturationTimestamp,\\n        Sponsorship calldata sponsorship\\n    )\\n        external\\n        nonReentrant\\n        sponsored(\\n            sponsorship,\\n            this.sponsoredRolloverDeposit.selector,\\n            abi.encode(depositID, maturationTimestamp)\\n        )\\n        returns (uint256 newDepositID, uint256 interestAmount)\\n    {\\n        return\\n            _rolloverDeposit(\\n                sponsorship.sender,\\n                depositID,\\n                maturationTimestamp\\n            );\\n    }\\n\\n    function sponsoredWithdraw(\\n        uint64 depositID,\\n        uint256 virtualTokenAmount,\\n        bool early,\\n        Sponsorship calldata sponsorship\\n    )\\n        external\\n        nonReentrant\\n        sponsored(\\n            sponsorship,\\n            this.sponsoredWithdraw.selector,\\n            abi.encode(depositID, virtualTokenAmount, early)\\n        )\\n        returns (uint256 withdrawnStablecoinAmount)\\n    {\\n        return\\n            _withdraw(\\n                sponsorship.sender,\\n                depositID,\\n                virtualTokenAmount,\\n                early,\\n                false\\n            );\\n    }\\n\\n    function sponsoredFund(\\n        uint64 depositID,\\n        uint256 fundAmount,\\n        Sponsorship calldata sponsorship\\n    )\\n        external\\n        nonReentrant\\n        sponsored(\\n            sponsorship,\\n            this.sponsoredFund.selector,\\n            abi.encode(depositID, fundAmount)\\n        )\\n        returns (uint64 fundingID)\\n    {\\n        return _fund(sponsorship.sender, depositID, fundAmount);\\n    }\\n\\n    function sponsoredPayInterestToFunders(\\n        uint64 fundingID,\\n        Sponsorship calldata sponsorship\\n    )\\n        external\\n        nonReentrant\\n        sponsored(\\n            sponsorship,\\n            this.sponsoredPayInterestToFunders.selector,\\n            abi.encode(fundingID)\\n        )\\n        returns (uint256 interestAmount)\\n    {\\n        return _payInterestToFunders(fundingID);\\n    }\\n\\n    /**\\n        Public getter functions\\n     */\\n\\n    /**\\n        @notice Computes the amount of fixed-rate interest (before fees) that\\n                will be given to a deposit of `depositAmount` stablecoins that\\n                matures in `depositPeriodInSeconds` seconds.\\n        @param depositAmount The deposit amount, in stablecoins\\n        @param depositPeriodInSeconds The deposit period, in seconds\\n        @return interestAmount The amount of fixed-rate interest (before fees)\\n     */\\n    function calculateInterestAmount(\\n        uint256 depositAmount,\\n        uint256 depositPeriodInSeconds\\n    ) public virtual returns (uint256 interestAmount) {\\n        (, uint256 moneyMarketInterestRatePerSecond) =\\n            interestOracle.updateAndQuery();\\n        (bool surplusIsNegative, uint256 surplusAmount) = surplus();\\n\\n        return\\n            interestModel.calculateInterestAmount(\\n                depositAmount,\\n                depositPeriodInSeconds,\\n                moneyMarketInterestRatePerSecond,\\n                surplusIsNegative,\\n                surplusAmount\\n            );\\n    }\\n\\n    /**\\n        @notice Computes the pool's overall surplus, which is the value of its holdings\\n                in the `moneyMarket` minus the amount owed to depositors, funders, and\\n                the fee beneficiary.\\n        @return isNegative True if the surplus is negative, false otherwise\\n        @return surplusAmount The absolute value of the surplus, in stablecoins\\n     */\\n    function surplus()\\n        public\\n        virtual\\n        returns (bool isNegative, uint256 surplusAmount)\\n    {\\n        // compute totalInterestOwedToFunders\\n        uint256 currentValue =\\n            (moneyMarket.incomeIndex() *\\n                sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex) /\\n                EXTRA_PRECISION;\\n        uint256 initialValue = totalFundedPrincipalAmount;\\n        uint256 totalInterestOwedToFunders;\\n        if (currentValue > initialValue) {\\n            totalInterestOwedToFunders = currentValue - initialValue;\\n        }\\n\\n        // compute surplus\\n        uint256 totalValue = moneyMarket.totalValue();\\n        uint256 totalOwed =\\n            totalDeposit +\\n                totalInterestOwed +\\n                totalFeeOwed +\\n                totalInterestOwedToFunders;\\n        if (totalValue >= totalOwed) {\\n            // Locked value more than owed deposits, positive surplus\\n            isNegative = false;\\n            surplusAmount = totalValue - totalOwed;\\n        } else {\\n            // Locked value less than owed deposits, negative surplus\\n            isNegative = true;\\n            surplusAmount = totalOwed - totalValue;\\n        }\\n    }\\n\\n    /**\\n        @notice Computes the raw surplus of a deposit, which is the current value of the\\n                deposit in the money market minus the amount owed (deposit + interest + fee).\\n                The deposit's funding status is not considered here, meaning even if a deposit's\\n                fixed-rate interest is fully funded, it likely will still have a non-zero surplus.\\n        @param depositID The ID of the deposit\\n        @return isNegative True if the surplus is negative, false otherwise\\n        @return surplusAmount The absolute value of the surplus, in stablecoins\\n     */\\n    function rawSurplusOfDeposit(uint64 depositID)\\n        public\\n        virtual\\n        returns (bool isNegative, uint256 surplusAmount)\\n    {\\n        Deposit memory depositEntry = _getDeposit(depositID);\\n        uint256 currentMoneyMarketIncomeIndex = moneyMarket.incomeIndex();\\n        uint256 depositTokenTotalSupply = depositEntry.virtualTokenTotalSupply;\\n        uint256 depositAmount =\\n            depositTokenTotalSupply.decdiv(\\n                depositEntry.interestRate + PRECISION\\n            );\\n        uint256 interestAmount = depositTokenTotalSupply - depositAmount;\\n        uint256 feeAmount = depositAmount.decmul(depositEntry.feeRate);\\n        uint256 currentDepositValue =\\n            (depositAmount * currentMoneyMarketIncomeIndex) /\\n                depositEntry.averageRecordedIncomeIndex;\\n        uint256 owed = depositAmount + interestAmount + feeAmount;\\n        if (currentDepositValue >= owed) {\\n            // Locked value more than owed deposits, positive surplus\\n            isNegative = false;\\n            surplusAmount = currentDepositValue - owed;\\n        } else {\\n            // Locked value less than owed deposits, negative surplus\\n            isNegative = true;\\n            surplusAmount = owed - currentDepositValue;\\n        }\\n    }\\n\\n    /**\\n        @notice Returns the total number of deposits.\\n        @return deposits.length\\n     */\\n    function depositsLength() external view returns (uint256) {\\n        return deposits.length;\\n    }\\n\\n    /**\\n        @notice Returns the total number of floating-rate bonds.\\n        @return fundingList.length\\n     */\\n    function fundingListLength() external view returns (uint256) {\\n        return fundingList.length;\\n    }\\n\\n    /**\\n        @notice Returns the Deposit struct associated with the deposit with ID\\n                `depositID`.\\n        @param depositID The ID of the deposit\\n        @return The deposit struct\\n     */\\n    function getDeposit(uint64 depositID)\\n        external\\n        view\\n        returns (Deposit memory)\\n    {\\n        return deposits[depositID - 1];\\n    }\\n\\n    /**\\n        @notice Returns the Funding struct associated with the floating-rate bond with ID\\n                `fundingID`.\\n        @param fundingID The ID of the floating-rate bond\\n        @return The Funding struct\\n     */\\n    function getFunding(uint64 fundingID)\\n        external\\n        view\\n        returns (Funding memory)\\n    {\\n        return fundingList[fundingID - 1];\\n    }\\n\\n    /**\\n        Internal action functions\\n     */\\n\\n    /**\\n        @dev See {deposit}\\n     */\\n    function _deposit(\\n        address sender,\\n        uint256 depositAmount,\\n        uint64 maturationTimestamp,\\n        bool rollover\\n    ) internal virtual returns (uint64 depositID, uint256 interestAmount) {\\n        (depositID, interestAmount) = _depositRecordData(\\n            sender,\\n            depositAmount,\\n            maturationTimestamp\\n        );\\n        _depositTransferFunds(sender, depositAmount, rollover);\\n    }\\n\\n    function _depositRecordData(\\n        address sender,\\n        uint256 depositAmount,\\n        uint64 maturationTimestamp\\n    ) internal virtual returns (uint64 depositID, uint256 interestAmount) {\\n        // Ensure input is valid\\n        require(depositAmount >= MinDepositAmount, \\\"DInterest: BAD_AMOUNT\\\");\\n        uint256 depositPeriod = maturationTimestamp - block.timestamp;\\n        require(depositPeriod <= MaxDepositPeriod, \\\"DInterest: BAD_TIME\\\");\\n\\n        // Calculate interest\\n        interestAmount = calculateInterestAmount(depositAmount, depositPeriod);\\n        require(interestAmount > 0, \\\"DInterest: BAD_INTEREST\\\");\\n\\n        // Calculate fee\\n        depositID = uint64(deposits.length) + 1;\\n        uint256 feeAmount =\\n            feeModel.getInterestFeeAmount(address(this), interestAmount);\\n        interestAmount -= feeAmount;\\n\\n        // Record deposit data\\n        deposits.push(\\n            Deposit({\\n                virtualTokenTotalSupply: depositAmount + interestAmount,\\n                interestRate: interestAmount.decdiv(depositAmount),\\n                feeRate: feeAmount.decdiv(depositAmount),\\n                maturationTimestamp: maturationTimestamp,\\n                fundingID: 0,\\n                averageRecordedIncomeIndex: moneyMarket.incomeIndex()\\n            })\\n        );\\n\\n        // Update global values\\n        totalDeposit += depositAmount;\\n        totalInterestOwed += interestAmount;\\n        totalFeeOwed += feeAmount;\\n\\n        // Mint depositNFT\\n        depositNFT.mint(sender, depositID);\\n\\n        // Vest MPH to sender\\n        mphMinter.createVestForDeposit(sender, depositID);\\n\\n        // Emit event\\n        emit EDeposit(\\n            sender,\\n            depositID,\\n            depositAmount,\\n            interestAmount,\\n            feeAmount,\\n            maturationTimestamp\\n        );\\n    }\\n\\n    function _depositTransferFunds(\\n        address sender,\\n        uint256 depositAmount,\\n        bool rollover\\n    ) internal virtual {\\n        // Only transfer funds from sender if it's not a rollover\\n        // because if it is the funds are already in the contract\\n        if (!rollover) {\\n            // Transfer `depositAmount` stablecoin to DInterest\\n            stablecoin.safeTransferFrom(sender, address(this), depositAmount);\\n\\n            // Lend `depositAmount` stablecoin to money market\\n            stablecoin.safeApprove(address(moneyMarket), depositAmount);\\n            moneyMarket.deposit(depositAmount);\\n        }\\n    }\\n\\n    /**\\n        @dev See {topupDeposit}\\n     */\\n    function _topupDeposit(\\n        address sender,\\n        uint64 depositID,\\n        uint256 depositAmount\\n    ) internal virtual returns (uint256 interestAmount) {\\n        interestAmount = _topupDepositRecordData(\\n            sender,\\n            depositID,\\n            depositAmount\\n        );\\n        _topupDepositTransferFunds(sender, depositAmount);\\n    }\\n\\n    function _topupDepositRecordData(\\n        address sender,\\n        uint64 depositID,\\n        uint256 depositAmount\\n    ) internal virtual returns (uint256 interestAmount) {\\n        Deposit memory depositEntry = _getDeposit(depositID);\\n        require(\\n            depositNFT.ownerOf(depositID) == sender,\\n            \\\"DInterest: NOT_OWNER\\\"\\n        );\\n\\n        // underflow check prevents topups after maturation\\n        uint256 depositPeriod =\\n            depositEntry.maturationTimestamp - block.timestamp;\\n\\n        // Calculate interest\\n        interestAmount = calculateInterestAmount(depositAmount, depositPeriod);\\n        require(interestAmount > 0, \\\"DInterest: BAD_INTEREST\\\");\\n\\n        // Calculate fee\\n        uint256 feeAmount =\\n            feeModel.getInterestFeeAmount(address(this), interestAmount);\\n        interestAmount -= feeAmount;\\n\\n        // Update deposit struct\\n        uint256 currentDepositAmount =\\n            depositEntry.virtualTokenTotalSupply.decdiv(\\n                depositEntry.interestRate + PRECISION\\n            );\\n        depositEntry.virtualTokenTotalSupply += depositAmount + interestAmount;\\n        depositEntry.interestRate =\\n            (PRECISION *\\n                interestAmount +\\n                currentDepositAmount *\\n                depositEntry.interestRate) /\\n            (depositAmount + currentDepositAmount);\\n        depositEntry.feeRate =\\n            (PRECISION *\\n                feeAmount +\\n                currentDepositAmount *\\n                depositEntry.feeRate) /\\n            (depositAmount + currentDepositAmount);\\n        uint256 sumOfRecordedDepositAmountDivRecordedIncomeIndex =\\n            (currentDepositAmount * EXTRA_PRECISION) /\\n                depositEntry.averageRecordedIncomeIndex +\\n                (depositAmount * EXTRA_PRECISION) /\\n                moneyMarket.incomeIndex();\\n        depositEntry.averageRecordedIncomeIndex =\\n            ((depositAmount + currentDepositAmount) * EXTRA_PRECISION) /\\n            sumOfRecordedDepositAmountDivRecordedIncomeIndex;\\n\\n        deposits[depositID - 1] = depositEntry;\\n\\n        // Update global values\\n        totalDeposit += depositAmount;\\n        totalInterestOwed += interestAmount;\\n        totalFeeOwed += feeAmount;\\n\\n        // Update vest\\n        mphMinter.updateVestForDeposit(\\n            depositID,\\n            currentDepositAmount,\\n            depositAmount\\n        );\\n\\n        // Emit event\\n        emit ETopupDeposit(\\n            sender,\\n            depositID,\\n            depositAmount,\\n            interestAmount,\\n            feeAmount\\n        );\\n    }\\n\\n    function _topupDepositTransferFunds(address sender, uint256 depositAmount)\\n        internal\\n        virtual\\n    {\\n        // Transfer `depositAmount` stablecoin to DInterest\\n        stablecoin.safeTransferFrom(sender, address(this), depositAmount);\\n\\n        // Lend `depositAmount` stablecoin to money market\\n        stablecoin.safeApprove(address(moneyMarket), depositAmount);\\n        moneyMarket.deposit(depositAmount);\\n    }\\n\\n    /**\\n        @dev See {rolloverDeposit}\\n     */\\n    function _rolloverDeposit(\\n        address sender,\\n        uint64 depositID,\\n        uint64 maturationTimestamp\\n    ) internal virtual returns (uint64 newDepositID, uint256 interestAmount) {\\n        // withdraw from existing deposit\\n        uint256 withdrawnStablecoinAmount =\\n            _withdraw(sender, depositID, type(uint256).max, false, true);\\n\\n        // deposit funds into a new deposit\\n        (newDepositID, interestAmount) = _deposit(\\n            sender,\\n            withdrawnStablecoinAmount,\\n            maturationTimestamp,\\n            true\\n        );\\n\\n        emit ERolloverDeposit(sender, depositID, newDepositID);\\n    }\\n\\n    /**\\n        @dev See {withdraw}\\n        @param rollover True if being called from {_rolloverDeposit}, false otherwise\\n     */\\n    function _withdraw(\\n        address sender,\\n        uint64 depositID,\\n        uint256 virtualTokenAmount,\\n        bool early,\\n        bool rollover\\n    ) internal virtual returns (uint256 withdrawnStablecoinAmount) {\\n        (\\n            uint256 withdrawAmount,\\n            uint256 feeAmount,\\n            uint256 fundingInterestAmount,\\n            uint256 refundAmount\\n        ) = _withdrawRecordData(sender, depositID, virtualTokenAmount, early);\\n        return\\n            _withdrawTransferFunds(\\n                sender,\\n                _getDeposit(depositID).fundingID,\\n                withdrawAmount,\\n                feeAmount,\\n                fundingInterestAmount,\\n                refundAmount,\\n                rollover\\n            );\\n    }\\n\\n    function _withdrawRecordData(\\n        address sender,\\n        uint64 depositID,\\n        uint256 virtualTokenAmount,\\n        bool early\\n    )\\n        internal\\n        virtual\\n        returns (\\n            uint256 withdrawAmount,\\n            uint256 feeAmount,\\n            uint256 fundingInterestAmount,\\n            uint256 refundAmount\\n        )\\n    {\\n        // Verify input\\n        require(virtualTokenAmount > 0, \\\"DInterest: BAD_AMOUNT\\\");\\n        Deposit memory depositEntry = _getDeposit(depositID);\\n        if (early) {\\n            require(\\n                block.timestamp < depositEntry.maturationTimestamp,\\n                \\\"DInterest: MATURE\\\"\\n            );\\n        } else {\\n            require(\\n                block.timestamp >= depositEntry.maturationTimestamp,\\n                \\\"DInterest: IMMATURE\\\"\\n            );\\n        }\\n        require(\\n            depositNFT.ownerOf(depositID) == sender,\\n            \\\"DInterest: NOT_OWNER\\\"\\n        );\\n\\n        // Check if withdrawing all funds\\n        if (virtualTokenAmount > depositEntry.virtualTokenTotalSupply) {\\n            virtualTokenAmount = depositEntry.virtualTokenTotalSupply;\\n        }\\n\\n        // Compute token amounts\\n        uint256 depositAmount =\\n            virtualTokenAmount.decdiv(depositEntry.interestRate + PRECISION);\\n        {\\n            uint256 interestAmount =\\n                early ? 0 : virtualTokenAmount - depositAmount;\\n            withdrawAmount = depositAmount + interestAmount;\\n        }\\n        if (early) {\\n            // apply fee to withdrawAmount\\n            uint256 earlyWithdrawFee =\\n                feeModel.getEarlyWithdrawFeeAmount(\\n                    address(this),\\n                    depositID,\\n                    withdrawAmount\\n                );\\n            feeAmount = earlyWithdrawFee;\\n            withdrawAmount -= earlyWithdrawFee;\\n        } else {\\n            feeAmount = depositAmount.decmul(depositEntry.feeRate);\\n        }\\n\\n        // Update global values\\n        totalDeposit -= depositAmount;\\n        totalInterestOwed -= virtualTokenAmount - depositAmount;\\n        totalFeeOwed -= depositAmount.decmul(depositEntry.feeRate);\\n\\n        // If deposit was funded, compute funding interest payout\\n        if (depositEntry.fundingID > 0) {\\n            Funding storage funding = _getFunding(depositEntry.fundingID);\\n\\n            // Compute funded deposit amount before withdrawal\\n            uint256 fundingTokenTotalSupply =\\n                fundingMultitoken.totalSupply(depositEntry.fundingID);\\n            uint256 recordedFundedPrincipalAmount =\\n                (fundingTokenTotalSupply * funding.principalPerToken) /\\n                    ULTRA_PRECISION;\\n            uint256 totalPrincipal =\\n                _depositVirtualTokenToPrincipal(\\n                    depositID,\\n                    depositEntry.virtualTokenTotalSupply\\n                );\\n\\n            // Shrink funding principal per token value\\n            uint256 totalPrincipalDecrease =\\n                virtualTokenAmount + depositAmount.decmul(depositEntry.feeRate);\\n            if (\\n                totalPrincipal <=\\n                totalPrincipalDecrease + recordedFundedPrincipalAmount\\n            ) {\\n                // Not enough unfunded principal, need to decrease funding principal per token value\\n                funding.principalPerToken =\\n                    (funding.principalPerToken *\\n                        (totalPrincipal - totalPrincipalDecrease)) /\\n                    recordedFundedPrincipalAmount;\\n            }\\n\\n            // Compute interest payout + refund\\n            // and update relevant state\\n            (\\n                fundingInterestAmount,\\n                refundAmount\\n            ) = _computeAndUpdateFundingInterestAfterWithdraw(\\n                depositEntry.fundingID,\\n                recordedFundedPrincipalAmount,\\n                early\\n            );\\n        }\\n\\n        // Update vest\\n        {\\n            uint256 depositAmountBeforeWithdrawal =\\n                _getDeposit(depositID).virtualTokenTotalSupply.decdiv(\\n                    depositEntry.interestRate + PRECISION\\n                );\\n            mphMinter.updateVestForDeposit(\\n                depositID,\\n                depositAmountBeforeWithdrawal,\\n                0\\n            );\\n        }\\n\\n        // Burn `virtualTokenAmount` deposit virtual tokens\\n        _getDeposit(depositID).virtualTokenTotalSupply -= virtualTokenAmount;\\n\\n        // Emit event\\n        emit EWithdraw(sender, depositID, early, virtualTokenAmount, feeAmount);\\n    }\\n\\n    function _withdrawTransferFunds(\\n        address sender,\\n        uint64 fundingID,\\n        uint256 withdrawAmount,\\n        uint256 feeAmount,\\n        uint256 fundingInterestAmount,\\n        uint256 refundAmount,\\n        bool rollover\\n    ) internal virtual returns (uint256 withdrawnStablecoinAmount) {\\n        // Withdraw funds from money market\\n        // Withdraws principal together with funding interest to save gas\\n        if (rollover) {\\n            // Rollover mode, don't withdraw `withdrawAmount` from moneyMarket\\n\\n            // We do this because feePlusFundingInterest might\\n            // be slightly less due to rounding\\n            uint256 feePlusFundingInterest =\\n                moneyMarket.withdraw(feeAmount + fundingInterestAmount);\\n            if (feePlusFundingInterest >= feeAmount + fundingInterestAmount) {\\n                // enough to pay everything, if there's extra give to feeAmount\\n                feeAmount = feePlusFundingInterest - fundingInterestAmount;\\n            } else if (feePlusFundingInterest >= feeAmount) {\\n                // enough to pay fee, give remainder to fundingInterestAmount\\n                fundingInterestAmount = feePlusFundingInterest - feeAmount;\\n            } else {\\n                // not enough to pay fee, give everything to fee\\n                feeAmount = feePlusFundingInterest;\\n                fundingInterestAmount = 0;\\n            }\\n\\n            // we're keeping the withdrawal amount in the money market\\n            withdrawnStablecoinAmount = withdrawAmount;\\n        } else {\\n            uint256 actualWithdrawnAmount =\\n                moneyMarket.withdraw(\\n                    withdrawAmount + feeAmount + fundingInterestAmount\\n                );\\n\\n            // We do this because `actualWithdrawnAmount` might\\n            // be slightly less due to rounding\\n            withdrawnStablecoinAmount = withdrawAmount;\\n            if (\\n                actualWithdrawnAmount >=\\n                withdrawAmount + feeAmount + fundingInterestAmount\\n            ) {\\n                // enough to pay everything, if there's extra give to feeAmount\\n                feeAmount =\\n                    actualWithdrawnAmount -\\n                    withdrawAmount -\\n                    fundingInterestAmount;\\n            } else if (actualWithdrawnAmount >= withdrawAmount + feeAmount) {\\n                // enough to pay withdrawal + fee + remainder\\n                // give remainder to funding interest\\n                fundingInterestAmount =\\n                    actualWithdrawnAmount -\\n                    withdrawAmount -\\n                    feeAmount;\\n            } else if (actualWithdrawnAmount >= withdrawAmount) {\\n                // enough to pay withdrawal + remainder\\n                // give remainder to fee\\n                feeAmount = actualWithdrawnAmount - withdrawAmount;\\n            } else {\\n                // not enough to pay withdrawal\\n                // give everything to withdrawal\\n                withdrawnStablecoinAmount = actualWithdrawnAmount;\\n            }\\n\\n            if (withdrawnStablecoinAmount > 0) {\\n                stablecoin.safeTransfer(sender, withdrawnStablecoinAmount);\\n            }\\n        }\\n\\n        // Send `feeAmount` stablecoin to feeModel beneficiary\\n        if (feeAmount > 0) {\\n            stablecoin.safeTransfer(feeModel.beneficiary(), feeAmount);\\n        }\\n\\n        // Distribute `fundingInterestAmount` stablecoins to funders\\n        if (fundingInterestAmount > 0) {\\n            stablecoin.safeApprove(\\n                address(fundingMultitoken),\\n                fundingInterestAmount\\n            );\\n            fundingMultitoken.distributeDividends(\\n                fundingID,\\n                address(stablecoin),\\n                fundingInterestAmount\\n            );\\n            // Mint funder rewards\\n            if (fundingInterestAmount >= refundAmount) {\\n                mphMinter.distributeFundingRewards(\\n                    fundingID,\\n                    fundingInterestAmount - refundAmount\\n                );\\n            }\\n        }\\n    }\\n\\n    /**\\n        @dev See {fund}\\n     */\\n    function _fund(\\n        address sender,\\n        uint64 depositID,\\n        uint256 fundAmount\\n    ) internal virtual returns (uint64 fundingID) {\\n        uint256 actualFundAmount;\\n        (fundingID, actualFundAmount) = _fundRecordData(\\n            sender,\\n            depositID,\\n            fundAmount\\n        );\\n        _fundTransferFunds(sender, actualFundAmount);\\n    }\\n\\n    function _fundRecordData(\\n        address sender,\\n        uint64 depositID,\\n        uint256 fundAmount\\n    ) internal virtual returns (uint64 fundingID, uint256 actualFundAmount) {\\n        Deposit storage depositEntry = _getDeposit(depositID);\\n\\n        (bool isNegative, uint256 surplusMagnitude) = surplus();\\n        require(isNegative, \\\"DInterest: NO_DEBT\\\");\\n\\n        (isNegative, surplusMagnitude) = rawSurplusOfDeposit(depositID);\\n        require(isNegative, \\\"DInterest: NO_DEBT\\\");\\n        if (fundAmount > surplusMagnitude) {\\n            fundAmount = surplusMagnitude;\\n        }\\n\\n        // Create funding struct if one doesn't exist\\n        uint256 incomeIndex = moneyMarket.incomeIndex();\\n        require(incomeIndex > 0, \\\"DInterest: BAD_INDEX\\\");\\n        uint256 totalPrincipal =\\n            _depositVirtualTokenToPrincipal(\\n                depositID,\\n                depositEntry.virtualTokenTotalSupply\\n            );\\n        uint256 totalPrincipalToFund;\\n        fundingID = depositEntry.fundingID;\\n        uint256 mintTokenAmount;\\n        if (fundingID == 0 || _getFunding(fundingID).principalPerToken == 0) {\\n            // The first funder, create struct\\n            fundingList.push(\\n                Funding({\\n                    depositID: depositID,\\n                    recordedMoneyMarketIncomeIndex: incomeIndex,\\n                    principalPerToken: ULTRA_PRECISION\\n                })\\n            );\\n            fundingID = uint64(fundingList.length);\\n            depositEntry.fundingID = fundingID;\\n            totalPrincipalToFund =\\n                (totalPrincipal * fundAmount) /\\n                surplusMagnitude;\\n            mintTokenAmount = totalPrincipalToFund;\\n        } else {\\n            // Not the first funder\\n            // Trigger interest payment for existing funders\\n            _payInterestToFunders(fundingID);\\n\\n            // Compute amount of principal to fund\\n            uint256 principalPerToken =\\n                _getFunding(fundingID).principalPerToken;\\n            uint256 unfundedPrincipalAmount =\\n                totalPrincipal -\\n                    (fundingMultitoken.totalSupply(fundingID) *\\n                        principalPerToken) /\\n                    ULTRA_PRECISION;\\n            surplusMagnitude =\\n                (surplusMagnitude * unfundedPrincipalAmount) /\\n                totalPrincipal;\\n            if (fundAmount > surplusMagnitude) {\\n                fundAmount = surplusMagnitude;\\n            }\\n            totalPrincipalToFund =\\n                (unfundedPrincipalAmount * fundAmount) /\\n                surplusMagnitude;\\n            mintTokenAmount =\\n                (totalPrincipalToFund * ULTRA_PRECISION) /\\n                principalPerToken;\\n        }\\n        // Mint funding multitoken\\n        fundingMultitoken.mint(sender, fundingID, mintTokenAmount);\\n\\n        // Update relevant values\\n        sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex +=\\n            (totalPrincipalToFund * EXTRA_PRECISION) /\\n            incomeIndex;\\n        totalFundedPrincipalAmount += totalPrincipalToFund;\\n\\n        // Emit event\\n        emit EFund(sender, fundingID, fundAmount, mintTokenAmount);\\n\\n        actualFundAmount = fundAmount;\\n    }\\n\\n    function _fundTransferFunds(address sender, uint256 fundAmount)\\n        internal\\n        virtual\\n    {\\n        // Transfer `fundAmount` stablecoins from sender\\n        stablecoin.safeTransferFrom(sender, address(this), fundAmount);\\n\\n        // Deposit `fundAmount` stablecoins into moneyMarket\\n        stablecoin.safeApprove(address(moneyMarket), fundAmount);\\n        moneyMarket.deposit(fundAmount);\\n    }\\n\\n    /**\\n        @dev See {payInterestToFunders}\\n     */\\n    function _payInterestToFunders(uint64 fundingID)\\n        internal\\n        virtual\\n        returns (uint256 interestAmount)\\n    {\\n        Funding storage f = _getFunding(fundingID);\\n        uint256 recordedMoneyMarketIncomeIndex =\\n            f.recordedMoneyMarketIncomeIndex;\\n        uint256 currentMoneyMarketIncomeIndex = moneyMarket.incomeIndex();\\n        uint256 fundingTokenTotalSupply =\\n            fundingMultitoken.totalSupply(fundingID);\\n        uint256 recordedFundedPrincipalAmount =\\n            (fundingTokenTotalSupply * f.principalPerToken) / ULTRA_PRECISION;\\n\\n        // Update funding values\\n        sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex =\\n            sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex +\\n            (recordedFundedPrincipalAmount * EXTRA_PRECISION) /\\n            currentMoneyMarketIncomeIndex -\\n            (recordedFundedPrincipalAmount * EXTRA_PRECISION) /\\n            recordedMoneyMarketIncomeIndex;\\n        f.recordedMoneyMarketIncomeIndex = currentMoneyMarketIncomeIndex;\\n\\n        // Compute interest to funders\\n        interestAmount =\\n            (recordedFundedPrincipalAmount * currentMoneyMarketIncomeIndex) /\\n            recordedMoneyMarketIncomeIndex -\\n            recordedFundedPrincipalAmount;\\n\\n        // Distribute interest to funders\\n        if (interestAmount > 0) {\\n            interestAmount = moneyMarket.withdraw(interestAmount);\\n            if (interestAmount > 0) {\\n                stablecoin.safeApprove(\\n                    address(fundingMultitoken),\\n                    interestAmount\\n                );\\n                fundingMultitoken.distributeDividends(\\n                    fundingID,\\n                    address(stablecoin),\\n                    interestAmount\\n                );\\n\\n                // Mint funder rewards\\n                mphMinter.distributeFundingRewards(fundingID, interestAmount);\\n            }\\n        }\\n\\n        emit EPayFundingInterest(fundingID, interestAmount, 0);\\n    }\\n\\n    /**\\n        @dev Used in {_withdraw}. Computes the amount of interest to distribute\\n             to the deposit's floating-rate bond holders. Also updates the Funding\\n             struct associated with the floating-rate bond.\\n        @param fundingID The ID of the floating-rate bond\\n        @param recordedFundedPrincipalAmount The amount of principal funded before the withdrawal\\n        @param early True if withdrawing before maturation, false otherwise\\n        @return fundingInterestAmount The amount of interest to distribute to the floating-rate bond holders, plus the refund amount\\n        @return refundAmount The amount of refund caused by an early withdraw\\n     */\\n    function _computeAndUpdateFundingInterestAfterWithdraw(\\n        uint64 fundingID,\\n        uint256 recordedFundedPrincipalAmount,\\n        bool early\\n    )\\n        internal\\n        virtual\\n        returns (uint256 fundingInterestAmount, uint256 refundAmount)\\n    {\\n        Funding storage f = _getFunding(fundingID);\\n        uint256 recordedMoneyMarketIncomeIndex =\\n            f.recordedMoneyMarketIncomeIndex;\\n        uint256 currentMoneyMarketIncomeIndex = moneyMarket.incomeIndex();\\n        require(currentMoneyMarketIncomeIndex > 0, \\\"DInterest: BAD_INDEX\\\");\\n        uint256 currentFundedPrincipalAmount =\\n            (fundingMultitoken.totalSupply(fundingID) * f.principalPerToken) /\\n                ULTRA_PRECISION;\\n\\n        // Update funding values\\n        {\\n            uint256 currentFundedPrincipalAmountDivRecordedIncomeIndex =\\n                (currentFundedPrincipalAmount * EXTRA_PRECISION) /\\n                    currentMoneyMarketIncomeIndex;\\n            uint256 recordedFundedPrincipalAmountDivRecordedIncomeIndex =\\n                (recordedFundedPrincipalAmount * EXTRA_PRECISION) /\\n                    recordedMoneyMarketIncomeIndex;\\n            if (\\n                sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex +\\n                    currentFundedPrincipalAmountDivRecordedIncomeIndex >=\\n                recordedFundedPrincipalAmountDivRecordedIncomeIndex\\n            ) {\\n                sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex =\\n                    sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex +\\n                    currentFundedPrincipalAmountDivRecordedIncomeIndex -\\n                    recordedFundedPrincipalAmountDivRecordedIncomeIndex;\\n            } else {\\n                sumOfRecordedFundedPrincipalAmountDivRecordedIncomeIndex = 0;\\n            }\\n        }\\n\\n        f.recordedMoneyMarketIncomeIndex = currentMoneyMarketIncomeIndex;\\n        totalFundedPrincipalAmount -=\\n            recordedFundedPrincipalAmount -\\n            currentFundedPrincipalAmount;\\n\\n        // Compute interest to funders\\n        fundingInterestAmount =\\n            (recordedFundedPrincipalAmount * currentMoneyMarketIncomeIndex) /\\n            recordedMoneyMarketIncomeIndex -\\n            recordedFundedPrincipalAmount;\\n\\n        // Add refund to interestAmount\\n        if (early) {\\n            Deposit memory depositEntry = _getDeposit(f.depositID);\\n            (, uint256 moneyMarketInterestRatePerSecond) =\\n                interestOracle.updateAndQuery();\\n            refundAmount =\\n                (((recordedFundedPrincipalAmount -\\n                    currentFundedPrincipalAmount) * PRECISION)\\n                    .decmul(moneyMarketInterestRatePerSecond) *\\n                    (depositEntry.maturationTimestamp - block.timestamp)) /\\n                PRECISION;\\n            uint256 maxRefundAmount =\\n                (recordedFundedPrincipalAmount - currentFundedPrincipalAmount)\\n                    .decdiv(\\n                    PRECISION + depositEntry.interestRate + depositEntry.feeRate\\n                )\\n                    .decmul(depositEntry.interestRate + depositEntry.feeRate);\\n            refundAmount = refundAmount <= maxRefundAmount\\n                ? refundAmount\\n                : maxRefundAmount;\\n            fundingInterestAmount += refundAmount;\\n        }\\n\\n        emit EPayFundingInterest(\\n            fundingID,\\n            fundingInterestAmount,\\n            refundAmount\\n        );\\n    }\\n\\n    /**\\n        Internal getter functions\\n     */\\n\\n    /**\\n        @dev See {getDeposit}\\n     */\\n    function _getDeposit(uint64 depositID)\\n        internal\\n        view\\n        returns (Deposit storage)\\n    {\\n        return deposits[depositID - 1];\\n    }\\n\\n    /**\\n        @dev See {getFunding}\\n     */\\n    function _getFunding(uint64 fundingID)\\n        internal\\n        view\\n        returns (Funding storage)\\n    {\\n        return fundingList[fundingID - 1];\\n    }\\n\\n    /**\\n        @dev Converts a virtual token value into the corresponding principal value.\\n             Principal refers to deposit + full interest + fee.\\n        @param depositID The ID of the deposit of the virtual tokens\\n        @param virtualTokenAmount The virtual token value\\n        @return The corresponding principal value\\n     */\\n    function _depositVirtualTokenToPrincipal(\\n        uint64 depositID,\\n        uint256 virtualTokenAmount\\n    ) internal view virtual returns (uint256) {\\n        Deposit storage depositEntry = _getDeposit(depositID);\\n        uint256 depositInterestRate = depositEntry.interestRate;\\n        return\\n            virtualTokenAmount.decdiv(depositInterestRate + PRECISION).decmul(\\n                depositInterestRate + depositEntry.feeRate + PRECISION\\n            );\\n    }\\n\\n    /**\\n        @dev See {Rescuable._authorizeRescue}\\n     */\\n    function _authorizeRescue(\\n        address, /*token*/\\n        address /*target*/\\n    ) internal view override {\\n        require(msg.sender == owner(), \\\"DInterest: NOT_OWNER\\\");\\n    }\\n\\n    /**\\n        Param setters (only callable by the owner)\\n     */\\n    function setFeeModel(address newValue) external onlyOwner {\\n        require(newValue.isContract(), \\\"DInterest: NOT_CONTRACT\\\");\\n        feeModel = IFeeModel(newValue);\\n        emit ESetParamAddress(msg.sender, \\\"feeModel\\\", newValue);\\n    }\\n\\n    function setInterestModel(address newValue) external onlyOwner {\\n        require(newValue.isContract(), \\\"DInterest: NOT_CONTRACT\\\");\\n        interestModel = IInterestModel(newValue);\\n        emit ESetParamAddress(msg.sender, \\\"interestModel\\\", newValue);\\n    }\\n\\n    function setInterestOracle(address newValue) external onlyOwner {\\n        require(newValue.isContract(), \\\"DInterest: NOT_CONTRACT\\\");\\n        interestOracle = IInterestOracle(newValue);\\n        require(\\n            interestOracle.moneyMarket() == moneyMarket,\\n            \\\"DInterest: BAD_ORACLE\\\"\\n        );\\n        emit ESetParamAddress(msg.sender, \\\"interestOracle\\\", newValue);\\n    }\\n\\n    function setRewards(address newValue) external onlyOwner {\\n        require(newValue.isContract(), \\\"DInterest: NOT_CONTRACT\\\");\\n        moneyMarket.setRewards(newValue);\\n        emit ESetParamAddress(msg.sender, \\\"moneyMarket.rewards\\\", newValue);\\n    }\\n\\n    function setMPHMinter(address newValue) external onlyOwner {\\n        require(newValue.isContract(), \\\"DInterest: NOT_CONTRACT\\\");\\n        mphMinter = MPHMinter(newValue);\\n        emit ESetParamAddress(msg.sender, \\\"mphMinter\\\", newValue);\\n    }\\n\\n    function setMaxDepositPeriod(uint64 newValue) external onlyOwner {\\n        require(newValue > 0, \\\"DInterest: BAD_VAL\\\");\\n        MaxDepositPeriod = newValue;\\n        emit ESetParamUint(msg.sender, \\\"MaxDepositPeriod\\\", uint256(newValue));\\n    }\\n\\n    function setMinDepositAmount(uint256 newValue) external onlyOwner {\\n        require(newValue > 0, \\\"DInterest: BAD_VAL\\\");\\n        MinDepositAmount = newValue;\\n        emit ESetParamUint(msg.sender, \\\"MinDepositAmount\\\", newValue);\\n    }\\n\\n    function setDepositNFTBaseURI(string calldata newURI) external onlyOwner {\\n        depositNFT.setBaseURI(newURI);\\n    }\\n\\n    function setDepositNFTContractURI(string calldata newURI)\\n        external\\n        onlyOwner\\n    {\\n        depositNFT.setContractURI(newURI);\\n    }\\n\\n    function skimSurplus(address recipient) external onlyOwner {\\n        (bool isNegative, uint256 surplusMagnitude) = surplus();\\n        if (!isNegative) {\\n            surplusMagnitude = moneyMarket.withdraw(surplusMagnitude);\\n            stablecoin.safeTransfer(recipient, surplusMagnitude);\\n        }\\n    }\\n\\n    function decreaseFeeForDeposit(uint64 depositID, uint256 newFeeRate)\\n        external\\n        onlyOwner\\n    {\\n        Deposit memory depositMemory = _getDeposit(depositID);\\n        Deposit storage depositStorage = _getDeposit(depositID);\\n        require(newFeeRate < depositMemory.feeRate, \\\"DInterest: BAD_VAL\\\");\\n        uint256 depositAmount =\\n            depositMemory.virtualTokenTotalSupply.decdiv(\\n                depositMemory.interestRate + PRECISION\\n            );\\n\\n        // update fee rate\\n        depositStorage.feeRate = newFeeRate;\\n\\n        // update interest rate\\n        // fee reduction is allocated to interest\\n        uint256 reducedFeeAmount =\\n            depositAmount.decmul(depositMemory.feeRate - newFeeRate);\\n        depositStorage.interestRate =\\n            depositMemory.interestRate +\\n            reducedFeeAmount.decdiv(depositAmount);\\n\\n        // update global amounts\\n        totalInterestOwed += reducedFeeAmount;\\n        totalFeeOwed -= reducedFeeAmount;\\n    }\\n\\n    uint256[33] private __gap;\\n}\\n\",\"keccak256\":\"0xca8b9e576c2a7aec12a07f60ba7b135d8236b398eb2d508f184dd4470b07d915\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libs/DecMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.3;\\n\\n// Decimal math library\\nlibrary DecMath {\\n    uint256 internal constant PRECISION = 10**18;\\n\\n    function decmul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return (a * b) / PRECISION;\\n    }\\n\\n    function decdiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return (a * PRECISION) / b;\\n    }\\n}\\n\",\"keccak256\":\"0x830cccda720ec3797259ec651073e91c889e7e3aeec81e034c793ca9d106eb8b\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libs/ERC1155Base.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.3;\\n\\nimport {ERC1155Upgradeable} from \\\"./ERC1155Upgradeable.sol\\\";\\nimport {\\n    AccessControlUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\\\";\\n\\n/**\\n    @notice An extension of ERC1155 that provides access-controlled minting and burning,\\n            as well as a total supply getter for each token ID.\\n */\\nabstract contract ERC1155Base is ERC1155Upgradeable, AccessControlUpgradeable {\\n    bytes32 public constant MINTER_BURNER_ROLE =\\n        keccak256(\\\"MINTER_BURNER_ROLE\\\");\\n    bytes32 public constant METADATA_ROLE = keccak256(\\\"METADATA_ROLE\\\");\\n    bytes internal constant NULL_BYTES = bytes(\\\"\\\");\\n\\n    mapping(uint256 => uint256) private _totalSupply;\\n\\n    function __ERC1155Base_init(address admin, string memory uri)\\n        internal\\n        initializer\\n    {\\n        __ERC1155_init(uri);\\n        __ERC1155Base_init_unchained(admin);\\n    }\\n\\n    function __ERC1155Base_init_unchained(address admin) internal initializer {\\n        // admin is granted metadata role and minter-burner role\\n        // metadata role is managed by itself\\n        // minter-burner role is managed by itself\\n        _setupRole(METADATA_ROLE, admin);\\n        _setupRole(MINTER_BURNER_ROLE, admin);\\n        _setRoleAdmin(METADATA_ROLE, METADATA_ROLE);\\n        _setRoleAdmin(MINTER_BURNER_ROLE, MINTER_BURNER_ROLE);\\n    }\\n\\n    function mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        require(\\n            hasRole(MINTER_BURNER_ROLE, _msgSender()),\\n            \\\"ERC1155Base: must have minter-burner role to mint\\\"\\n        );\\n\\n        _mint(to, id, amount, NULL_BYTES);\\n    }\\n\\n    function mintBatch(\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) external {\\n        require(\\n            hasRole(MINTER_BURNER_ROLE, _msgSender()),\\n            \\\"ERC1155Base: must have minter-burner role to mint\\\"\\n        );\\n\\n        _mintBatch(to, ids, amounts, NULL_BYTES);\\n    }\\n\\n    function burn(\\n        address account,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        require(\\n            hasRole(MINTER_BURNER_ROLE, _msgSender()),\\n            \\\"ERC1155Base: must have minter-burner role to burn\\\"\\n        );\\n\\n        _burn(account, id, amount);\\n    }\\n\\n    function burnBatch(\\n        address account,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) external {\\n        require(\\n            hasRole(MINTER_BURNER_ROLE, _msgSender()),\\n            \\\"ERC1155Base: must have minter-burner role to burn\\\"\\n        );\\n\\n        _burnBatch(account, ids, amounts);\\n    }\\n\\n    function setURI(string calldata newuri) external {\\n        require(\\n            hasRole(METADATA_ROLE, _msgSender()),\\n            \\\"ERC1155Base: must have metadata role to set URI\\\"\\n        );\\n\\n        _setURI(newuri);\\n    }\\n\\n    function totalSupply(uint256 id) public view returns (uint256) {\\n        return _totalSupply[id];\\n    }\\n\\n    function totalSupplyBatch(uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory totalSupplies)\\n    {\\n        totalSupplies = new uint256[](ids.length);\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            totalSupplies[i] = _totalSupply[ids[i]];\\n        }\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override(ERC1155Upgradeable, AccessControlUpgradeable)\\n        returns (bool)\\n    {\\n        return super.supportsInterface(interfaceId);\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual override(ERC1155Upgradeable) {\\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        if (from == address(0)) {\\n            // Mint\\n            for (uint256 i = 0; i < ids.length; i++) {\\n                _totalSupply[ids[i]] += amounts[i];\\n            }\\n        } else if (to == address(0)) {\\n            // Burn\\n            for (uint256 i = 0; i < ids.length; i++) {\\n                _totalSupply[ids[i]] -= amounts[i];\\n            }\\n        }\\n    }\\n\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x663322e9f7ae782e1b2f98cfd1432a55eee80e6b0111593a880bd86a0e70027f\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libs/ERC1155DividendToken.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.3;\\n\\nimport {\\n    SafeCastUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"./SafeERC20.sol\\\";\\nimport {ERC1155Base} from \\\"./ERC1155Base.sol\\\";\\n\\n/**\\n    @notice An extension of ERC1155Base that allows distributing dividends to all holders\\n            of an token ID. Also supports multiple dividend tokens.\\n */\\nabstract contract ERC1155DividendToken is ERC1155Base {\\n    using SafeERC20 for IERC20;\\n    using SafeCastUpgradeable for uint256;\\n    using SafeCastUpgradeable for int256;\\n\\n    struct DividendTokenData {\\n        address dividendToken;\\n        mapping(uint256 => uint256) magnifiedDividendPerShare;\\n        // About dividendCorrection:\\n        // If the token balance of a `_user` is never changed, the dividend of `_user` can be computed with:\\n        //   `dividendOf(_user) = dividendPerShare * balanceOf(_user)`.\\n        // When `balanceOf(_user)` is changed (via minting/burning/transferring tokens),\\n        //   `dividendOf(_user)` should not be changed,\\n        //   but the computed value of `dividendPerShare * balanceOf(_user)` is changed.\\n        // To keep the `dividendOf(_user)` unchanged, we add a correction term:\\n        //   `dividendOf(_user) = dividendPerShare * balanceOf(_user) + dividendCorrectionOf(_user)`,\\n        //   where `dividendCorrectionOf(_user)` is updated whenever `balanceOf(_user)` is changed:\\n        //   `dividendCorrectionOf(_user) = dividendPerShare * (old balanceOf(_user)) - (new balanceOf(_user))`.\\n        // So now `dividendOf(_user)` returns the same value before and after `balanceOf(_user)` is changed.\\n        mapping(uint256 => mapping(address => int256)) magnifiedDividendCorrections;\\n        mapping(uint256 => mapping(address => uint256)) withdrawnDividends;\\n    }\\n\\n    // With `magnitude`, we can properly distribute dividends even if the amount of received target is small.\\n    // For more discussion about choosing the value of `magnitude`,\\n    //  see https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728\\n    uint256 internal constant magnitude = 2**128;\\n\\n    /**\\n        @notice The list of tokens that can be distributed to token holders as dividend. 1-indexed.\\n     */\\n    mapping(uint256 => DividendTokenData) public dividendTokenDataList;\\n    uint256 public dividendTokenDataListLength;\\n    /**\\n        @notice The dividend token address to its key in {dividendTokenDataList}\\n     */\\n    mapping(address => uint256) public dividendTokenToDataID;\\n\\n    /// @dev This event MUST emit when target is distributed to token holders.\\n    /// @param from The address which sends target to this contract.\\n    /// @param weiAmount The amount of distributed target in wei.\\n    event DividendsDistributed(\\n        uint256 indexed tokenID,\\n        address indexed from,\\n        address indexed dividendToken,\\n        uint256 weiAmount\\n    );\\n\\n    /// @dev This event MUST emit when an address withdraws their dividend.\\n    /// @param to The address which withdraws target from this contract.\\n    /// @param weiAmount The amount of withdrawn target in wei.\\n    event DividendWithdrawn(\\n        uint256 indexed tokenID,\\n        address indexed to,\\n        address indexed dividendToken,\\n        uint256 weiAmount\\n    );\\n\\n    function __ERC1155DividendToken_init(\\n        address[] memory dividendTokens,\\n        address admin,\\n        string memory uri\\n    ) internal initializer {\\n        __ERC1155Base_init(admin, uri);\\n        __ERC1155DividendToken_init_unchained(dividendTokens);\\n    }\\n\\n    function __ERC1155DividendToken_init_unchained(\\n        address[] memory dividendTokens\\n    ) internal initializer {\\n        dividendTokenDataListLength = dividendTokens.length;\\n        for (uint256 i = 0; i < dividendTokens.length; i++) {\\n            dividendTokenDataList[i + 1].dividendToken = dividendTokens[i];\\n            dividendTokenToDataID[dividendTokens[i]] = i + 1;\\n        }\\n    }\\n\\n    /**\\n        Public getters\\n     */\\n\\n    /// @notice View the amount of dividend in wei that an address can withdraw.\\n    /// @param tokenID The token's ID.\\n    /// @param dividendToken The token the dividend is in\\n    /// @param _owner The address of a token holder.\\n    /// @return The amount of dividend in wei that `_owner` can withdraw.\\n    function dividendOf(\\n        uint256 tokenID,\\n        address dividendToken,\\n        address _owner\\n    ) public view returns (uint256) {\\n        return _withdrawableDividendOf(tokenID, dividendToken, _owner);\\n    }\\n\\n    /// @notice View the amount of dividend in wei that an address has withdrawn.\\n    /// @param tokenID The token's ID.\\n    /// @param dividendToken The token the dividend is in\\n    /// @param _owner The address of a token holder.\\n    /// @return The amount of dividend in wei that `_owner` has withdrawn.\\n    function withdrawnDividendOf(\\n        uint256 tokenID,\\n        address dividendToken,\\n        address _owner\\n    ) public view returns (uint256) {\\n        uint256 dividendTokenDataID = dividendTokenToDataID[dividendToken];\\n        if (dividendTokenDataID == 0) {\\n            return 0;\\n        }\\n        DividendTokenData storage data =\\n            dividendTokenDataList[dividendTokenDataID];\\n        return data.withdrawnDividends[tokenID][_owner];\\n    }\\n\\n    /// @notice View the amount of dividend in wei that an address has earned in total.\\n    /// @dev accumulativeDividendOf(_owner) = _withdrawableDividendOf(_owner) + withdrawnDividendOf(_owner)\\n    /// = (magnifiedDividendPerShare * balanceOf(_owner) + magnifiedDividendCorrections[_owner]) / magnitude\\n    /// @param tokenID The token's ID.\\n    /// @param dividendToken The token the dividend is in\\n    /// @param _owner The address of a token holder.\\n    /// @return The amount of dividend in wei that `_owner` has earned in total.\\n    function accumulativeDividendOf(\\n        uint256 tokenID,\\n        address dividendToken,\\n        address _owner\\n    ) public view returns (uint256) {\\n        uint256 dividendTokenDataID = dividendTokenToDataID[dividendToken];\\n        if (dividendTokenDataID == 0) {\\n            return 0;\\n        }\\n        DividendTokenData storage data =\\n            dividendTokenDataList[dividendTokenDataID];\\n        return\\n            ((data.magnifiedDividendPerShare[tokenID] *\\n                balanceOf(_owner, tokenID))\\n                .toInt256() +\\n                data.magnifiedDividendCorrections[tokenID][_owner])\\n                .toUint256() / magnitude;\\n    }\\n\\n    /**\\n        Internal functions\\n     */\\n\\n    /// @notice View the amount of dividend in wei that an address can withdraw.\\n    /// @param tokenID The token's ID.\\n    /// @param dividendToken The token the dividend is in\\n    /// @param _owner The address of a token holder.\\n    /// @return The amount of dividend in wei that `_owner` can withdraw.\\n    function _withdrawableDividendOf(\\n        uint256 tokenID,\\n        address dividendToken,\\n        address _owner\\n    ) internal view returns (uint256) {\\n        uint256 dividendTokenDataID = dividendTokenToDataID[dividendToken];\\n        if (dividendTokenDataID == 0) {\\n            return 0;\\n        }\\n        DividendTokenData storage data =\\n            dividendTokenDataList[dividendTokenDataID];\\n        return\\n            accumulativeDividendOf(tokenID, dividendToken, _owner) -\\n            data.withdrawnDividends[tokenID][_owner];\\n    }\\n\\n    /// @notice Distributes target to token holders as dividends.\\n    /// @dev It reverts if the total supply of tokens is 0.\\n    /// It emits the `DividendsDistributed` event if the amount of received target is greater than 0.\\n    /// About undistributed target tokens:\\n    ///   In each distribution, there is a small amount of target not distributed,\\n    ///     the magnified amount of which is\\n    ///     `(amount * magnitude) % totalSupply()`.\\n    ///   With a well-chosen `magnitude`, the amount of undistributed target\\n    ///     (de-magnified) in a distribution can be less than 1 wei.\\n    ///   We can actually keep track of the undistributed target in a distribution\\n    ///     and try to distribute it in the next distribution,\\n    ///     but keeping track of such data on-chain costs much more than\\n    ///     the saved target, so we don't do that.\\n    function _distributeDividends(\\n        uint256 tokenID,\\n        address dividendToken,\\n        uint256 amount\\n    ) internal {\\n        uint256 tokenTotalSupply = totalSupply(tokenID);\\n        require(tokenTotalSupply > 0);\\n        require(amount > 0);\\n\\n        uint256 dividendTokenDataID = dividendTokenToDataID[dividendToken];\\n        require(\\n            dividendTokenDataID != 0,\\n            \\\"ERC1155DividendToken: invalid dividendToken\\\"\\n        );\\n        DividendTokenData storage data =\\n            dividendTokenDataList[dividendTokenDataID];\\n\\n        data.magnifiedDividendPerShare[tokenID] +=\\n            (amount * magnitude) /\\n            tokenTotalSupply;\\n\\n        IERC20(dividendToken).safeTransferFrom(\\n            msg.sender,\\n            address(this),\\n            amount\\n        );\\n\\n        emit DividendsDistributed(tokenID, msg.sender, dividendToken, amount);\\n    }\\n\\n    /// @notice Withdraws the target distributed to the sender.\\n    /// @dev It emits a `DividendWithdrawn` event if the amount of withdrawn target is greater than 0.\\n    function _withdrawDividend(\\n        uint256 tokenID,\\n        address dividendToken,\\n        address user\\n    ) internal {\\n        uint256 _withdrawableDividend =\\n            _withdrawableDividendOf(tokenID, dividendToken, user);\\n        if (_withdrawableDividend > 0) {\\n            uint256 dividendTokenDataID = dividendTokenToDataID[dividendToken];\\n            require(\\n                dividendTokenDataID != 0,\\n                \\\"ERC1155DividendToken: invalid dividendToken\\\"\\n            );\\n            DividendTokenData storage data =\\n                dividendTokenDataList[dividendTokenDataID];\\n            data.withdrawnDividends[tokenID][user] += _withdrawableDividend;\\n            emit DividendWithdrawn(\\n                tokenID,\\n                user,\\n                dividendToken,\\n                _withdrawableDividend\\n            );\\n            IERC20(dividendToken).safeTransfer(user, _withdrawableDividend);\\n        }\\n    }\\n\\n    function _registerDividendToken(address dividendToken)\\n        internal\\n        returns (uint256 newDividendTokenDataID)\\n    {\\n        require(\\n            dividendTokenToDataID[dividendToken] == 0,\\n            \\\"ERC1155DividendToken: already registered\\\"\\n        );\\n        dividendTokenDataListLength++;\\n        newDividendTokenDataID = dividendTokenDataListLength;\\n        dividendTokenDataList[newDividendTokenDataID]\\n            .dividendToken = dividendToken;\\n        dividendTokenToDataID[dividendToken] = newDividendTokenDataID;\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual override(ERC1155Base) {\\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        if (from == address(0)) {\\n            // Mint\\n            for (uint256 i = 0; i < ids.length; i++) {\\n                uint256 tokenID = ids[i];\\n                uint256 amount = amounts[i];\\n\\n                for (uint256 j = 1; j <= dividendTokenDataListLength; j++) {\\n                    DividendTokenData storage dividendTokenData =\\n                        dividendTokenDataList[j];\\n                    dividendTokenData.magnifiedDividendCorrections[tokenID][\\n                        to\\n                    ] -= (dividendTokenData.magnifiedDividendPerShare[tokenID] *\\n                        amount)\\n                        .toInt256();\\n                }\\n            }\\n        } else if (to == address(0)) {\\n            // Burn\\n            for (uint256 i = 0; i < ids.length; i++) {\\n                uint256 tokenID = ids[i];\\n                uint256 amount = amounts[i];\\n\\n                for (uint256 j = 1; j <= dividendTokenDataListLength; j++) {\\n                    DividendTokenData storage dividendTokenData =\\n                        dividendTokenDataList[j];\\n                    dividendTokenData.magnifiedDividendCorrections[tokenID][\\n                        from\\n                    ] += (dividendTokenData.magnifiedDividendPerShare[tokenID] *\\n                        amount)\\n                        .toInt256();\\n                }\\n            }\\n        } else {\\n            // Transfer\\n            for (uint256 i = 0; i < ids.length; i++) {\\n                uint256 tokenID = ids[i];\\n                uint256 amount = amounts[i];\\n\\n                for (uint256 j = 1; j <= dividendTokenDataListLength; j++) {\\n                    DividendTokenData storage dividendTokenData =\\n                        dividendTokenDataList[j];\\n                    int256 _magCorrection =\\n                        (dividendTokenData.magnifiedDividendPerShare[tokenID] *\\n                            amount)\\n                            .toInt256();\\n                    // Retain the rewards\\n                    dividendTokenData.magnifiedDividendCorrections[tokenID][\\n                        from\\n                    ] += _magCorrection;\\n                    dividendTokenData.magnifiedDividendCorrections[tokenID][\\n                        to\\n                    ] -= _magCorrection;\\n                }\\n            }\\n        }\\n    }\\n\\n    uint256[47] private __gap;\\n}\\n\",\"keccak256\":\"0xfc1894d240c7f6a47c0a726a220958c9dcbd08004d8ca36aff889508c78da398\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libs/ERC1155Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {\\n    IERC1155Upgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\\\";\\nimport {\\n    IERC1155ReceiverUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\\\";\\nimport {\\n    IERC1155MetadataURIUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol\\\";\\nimport {\\n    AddressUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport {\\n    ContextUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\\\";\\nimport {\\n    ERC165Upgradeable,\\n    IERC165Upgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\\\";\\nimport {\\n    Initializable\\n} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the basic standard multi-token.\\n * See https://eips.ethereum.org/EIPS/eip-1155\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\n *\\n * _Available since v3.1._\\n */\\ncontract ERC1155Upgradeable is\\n    Initializable,\\n    ContextUpgradeable,\\n    ERC165Upgradeable,\\n    IERC1155Upgradeable,\\n    IERC1155MetadataURIUpgradeable\\n{\\n    using AddressUpgradeable for address;\\n\\n    // Mapping from token ID to account balances\\n    mapping(uint256 => mapping(address => uint256)) private _balances;\\n\\n    // Mapping from account to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\n    string private _uri;\\n\\n    /**\\n     * @dev See {_setURI}.\\n     */\\n    function __ERC1155_init(string memory uri_) internal initializer {\\n        __Context_init_unchained();\\n        __ERC165_init_unchained();\\n        __ERC1155_init_unchained(uri_);\\n    }\\n\\n    function __ERC1155_init_unchained(string memory uri_) internal initializer {\\n        _setURI(uri_);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override(ERC165Upgradeable, IERC165Upgradeable)\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == type(IERC1155Upgradeable).interfaceId ||\\n            interfaceId == type(IERC1155MetadataURIUpgradeable).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     *\\n     * This implementation returns the same URI for *all* token types. It relies\\n     * on the token type ID substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\n     * actual token type ID.\\n     */\\n    function uri(uint256) public view virtual override returns (string memory) {\\n        return _uri;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        require(\\n            account != address(0),\\n            \\\"ERC1155: balance query for the zero address\\\"\\n        );\\n        return _balances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256[] memory)\\n    {\\n        require(\\n            accounts.length == ids.length,\\n            \\\"ERC1155: accounts and ids length mismatch\\\"\\n        );\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved)\\n        public\\n        virtual\\n        override\\n    {\\n        require(\\n            _msgSender() != operator,\\n            \\\"ERC1155: setting approval status for self\\\"\\n        );\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not owner nor approved\\\"\\n        );\\n        _safeTransferFrom(from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: transfer caller is not owner nor approved\\\"\\n        );\\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(\\n            operator,\\n            from,\\n            to,\\n            _asSingletonArray(id),\\n            _asSingletonArray(amount),\\n            data\\n        );\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(\\n            fromBalance >= amount,\\n            \\\"ERC1155: insufficient balance for transfer\\\"\\n        );\\n        _balances[id][from] = fromBalance - amount;\\n        _balances[id][to] += amount;\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(\\n            ids.length == amounts.length,\\n            \\\"ERC1155: ids and amounts length mismatch\\\"\\n        );\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = _balances[id][from];\\n            require(\\n                fromBalance >= amount,\\n                \\\"ERC1155: insufficient balance for transfer\\\"\\n            );\\n            _balances[id][from] = fromBalance - amount;\\n            _balances[id][to] += amount;\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(\\n            operator,\\n            from,\\n            to,\\n            ids,\\n            amounts,\\n            data\\n        );\\n    }\\n\\n    /**\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\n     * substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\n     * clients with the token type ID.\\n     *\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\n     * interpreted by clients as\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\n     * for token type ID 0x4cce0.\\n     *\\n     * See {uri}.\\n     *\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\n     * this function emits no events.\\n     */\\n    function _setURI(string memory newuri) internal virtual {\\n        _uri = newuri;\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(\\n        address account,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(account != address(0), \\\"ERC1155: mint to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(\\n            operator,\\n            address(0),\\n            account,\\n            _asSingletonArray(id),\\n            _asSingletonArray(amount),\\n            data\\n        );\\n\\n        _balances[id][account] += amount;\\n        emit TransferSingle(operator, address(0), account, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(\\n            operator,\\n            address(0),\\n            account,\\n            id,\\n            amount,\\n            data\\n        );\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n        require(\\n            ids.length == amounts.length,\\n            \\\"ERC1155: ids and amounts length mismatch\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][to] += amounts[i];\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(\\n            operator,\\n            address(0),\\n            to,\\n            ids,\\n            amounts,\\n            data\\n        );\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `account`\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(\\n        address account,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(\\n            operator,\\n            account,\\n            address(0),\\n            _asSingletonArray(id),\\n            _asSingletonArray(amount),\\n            \\\"\\\"\\n        );\\n\\n        uint256 accountBalance = _balances[id][account];\\n        require(\\n            accountBalance >= amount,\\n            \\\"ERC1155: burn amount exceeds balance\\\"\\n        );\\n        _balances[id][account] = accountBalance - amount;\\n\\n        emit TransferSingle(operator, account, address(0), id, amount);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(\\n        address account,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n        require(\\n            ids.length == amounts.length,\\n            \\\"ERC1155: ids and amounts length mismatch\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 accountBalance = _balances[id][account];\\n            require(\\n                accountBalance >= amount,\\n                \\\"ERC1155: burn amount exceeds balance\\\"\\n            );\\n            _balances[id][account] = accountBalance - amount;\\n        }\\n\\n        emit TransferBatch(operator, account, address(0), ids, amounts);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    /**\\n        @dev Override this to return true to skip checking to.onERC1155Received during\\n             single transfers.\\n     */\\n    function _shouldSkipSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual returns (bool) {\\n        return false;\\n    }\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) private {\\n        if (\\n            to.isContract() &&\\n            !_shouldSkipSafeTransferAcceptanceCheck(\\n                operator,\\n                from,\\n                to,\\n                id,\\n                amount,\\n                data\\n            )\\n        ) {\\n            try\\n                IERC1155ReceiverUpgradeable(to).onERC1155Received(\\n                    operator,\\n                    from,\\n                    id,\\n                    amount,\\n                    data\\n                )\\n            returns (bytes4 response) {\\n                if (\\n                    response !=\\n                    IERC1155ReceiverUpgradeable(to).onERC1155Received.selector\\n                ) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try\\n                IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived(\\n                    operator,\\n                    from,\\n                    ids,\\n                    amounts,\\n                    data\\n                )\\n            returns (bytes4 response) {\\n                if (\\n                    response !=\\n                    IERC1155ReceiverUpgradeable(to)\\n                        .onERC1155BatchReceived\\n                        .selector\\n                ) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _asSingletonArray(uint256 element)\\n        private\\n        pure\\n        returns (uint256[] memory)\\n    {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n\\n        return array;\\n    }\\n\\n    uint256[47] private __gap;\\n}\\n\",\"keccak256\":\"0x4af510c3f1262f73b11f97c887609f860e020bb3e74a333d3895f79f5c222362\",\"license\":\"MIT\"},\"contracts/libs/ERC20Wrapper.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.3;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {\\n    Initializable\\n} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport {WrappedERC1155Token} from \\\"./WrappedERC1155Token.sol\\\";\\n\\n/**\\n    @notice An ERC-20 wrapper for a particular tokenID of an ERC-1155 token\\n */\\ncontract ERC20Wrapper is Initializable, IERC20 {\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    WrappedERC1155Token public parentMultitoken;\\n    uint256 public tokenID;\\n    string public name;\\n    string public symbol;\\n    uint8 public decimals;\\n\\n    function initialize(\\n        address _parentMultitoken,\\n        uint256 _tokenID,\\n        string calldata _name,\\n        string calldata _symbol,\\n        uint8 _decimals\\n    ) external virtual initializer {\\n        parentMultitoken = WrappedERC1155Token(_parentMultitoken);\\n        tokenID = _tokenID;\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return parentMultitoken.totalSupply(tokenID);\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        return parentMultitoken.balanceOf(account, tokenID);\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        public\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount)\\n        public\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][msg.sender];\\n        require(\\n            currentAllowance >= amount,\\n            \\\"ERC20Wrapper: transfer amount exceeds allowance\\\"\\n        );\\n        _approve(sender, msg.sender, currentAllowance - amount);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        _approve(\\n            msg.sender,\\n            spender,\\n            _allowances[msg.sender][spender] + addedValue\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        uint256 currentAllowance = _allowances[msg.sender][spender];\\n        require(\\n            currentAllowance >= subtractedValue,\\n            \\\"ERC20Wrapper: decreased allowance below zero\\\"\\n        );\\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\\n\\n        return true;\\n    }\\n\\n    /**\\n        @dev Only callable by the parentMultitoken. Emits a transfer event when the parent token\\n             is transferred.\\n     */\\n    function emitTransferEvent(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external {\\n        require(\\n            msg.sender == address(parentMultitoken),\\n            \\\"ERC20Wrapper: not parent\\\"\\n        );\\n        emit Transfer(from, to, amount);\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        parentMultitoken.wrapperTransfer(\\n            msg.sender,\\n            recipient,\\n            tokenID,\\n            amount\\n        );\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(\\n            owner != address(0),\\n            \\\"ERC20Wrapper: approve from the zero address\\\"\\n        );\\n        require(\\n            spender != address(0),\\n            \\\"ERC20Wrapper: approve to the zero address\\\"\\n        );\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    uint256[44] private __gap;\\n}\\n\",\"keccak256\":\"0x6d5e96bbf604149da38bcc4538c5d5937e7509bfddc140ff3e9828a07aec57b6\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libs/Rescuable.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.3;\\n\\nimport {SafeERC20} from \\\"./SafeERC20.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n    @notice Inherit this to allow for rescuing ERC20 tokens sent to the contract in error.\\n */\\nabstract contract Rescuable {\\n    using SafeERC20 for IERC20;\\n\\n    /**\\n        @notice Rescues ERC20 tokens sent to the contract in error.\\n        @dev Need to implement {_authorizeRescue} to do access-control for this function.\\n        @param token The ERC20 token to rescue\\n        @param target The address to send the tokens to\\n     */\\n    function rescue(address token, address target) external virtual {\\n        // make sure we're not stealing funds or something\\n        _authorizeRescue(token, target);\\n\\n        // transfer token to target\\n        IERC20 tokenContract = IERC20(token);\\n        tokenContract.safeTransfer(\\n            target,\\n            tokenContract.balanceOf(address(this))\\n        );\\n    }\\n\\n    /**\\n        @dev Should revert if the rescue call should be stopped.\\n        @param token The ERC20 token to rescue\\n        @param target The address to send the tokens to\\n     */\\n    function _authorizeRescue(address token, address target) internal virtual;\\n\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x7a1dbe5e95306080b91665e84c6d00237e4b5354f04d67757d863cd33c952380\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libs/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transfer.selector, to, value)\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n        );\\n    }\\n\\n    /**\\n        @dev Modified from openzeppelin. Instead of reverting when the allowance is non-zero and value\\n        is non-zero, we first set the allowance to 0 and then call approve(spender, value).\\n        This provides support for non-standard tokens such as USDT that revert in this scenario. \\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        if ((token.allowance(address(this), spender)) > 0) {\\n            _callOptionalReturn(\\n                token,\\n                abi.encodeWithSelector(token.approve.selector, spender, 0)\\n            );\\n        }\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.approve.selector, spender, value)\\n        );\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata =\\n            address(token).functionCall(\\n                data,\\n                \\\"SafeERC20: low-level call failed\\\"\\n            );\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(\\n                abi.decode(returndata, (bool)),\\n                \\\"SafeERC20: ERC20 operation did not succeed\\\"\\n            );\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5c1ef68247c12919ad44823f36b0aea8b2c82b2185584a472afe59438e0059f4\",\"license\":\"MIT\"},\"contracts/libs/Sponsorable.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.3;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {ECDSA} from \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport {SafeERC20} from \\\"./SafeERC20.sol\\\";\\n\\n/**\\n    @notice Add support for meta-txs that use ERC20 tokens to pay for gas\\n */\\nabstract contract Sponsorable {\\n    using SafeERC20 for IERC20;\\n\\n    /**\\n        @dev Using uint256 for all numbers since this struct won't ever be in storage. This saves gas.\\n        @param sender The user who made the meta-tx\\n        @param sponsor The account that should receive the sponsor fee\\n        @param sponsorFeeToken The ERC20 token address the sponsor fee is paid in\\n        @param sponsorFeeAmount The amount of sponsor fee to transfer from `sender` to `sponsor`\\n        @param nonce The signature nonce used for preventing replay attacks. Should equal accountNonce[sender].\\n        @param deadline The timestamp after which the signature is invalid\\n        @param v ECDSA signature component: Parity of the `y` coordinate of point `R`\\n        @param r ECDSA signature component: x-coordinate of `R`\\n        @param s ECDSA signature component: `s` value of the signature\\n     */\\n    struct Sponsorship {\\n        address sender;\\n        address sponsor;\\n        address sponsorFeeToken;\\n        uint256 sponsorFeeAmount;\\n        uint256 nonce;\\n        uint256 deadline;\\n        uint256 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    mapping(address => uint256) public accountNonce;\\n\\n    /**\\n        @dev Use this for functions that should support meta-txs.\\n        @param sponsorship The sponsorship information\\n        @param funcSignature The function signature (selector) of the function being called\\n        @param encodedParams The parameters of the function, encoded using abi.encode()\\n     */\\n    modifier sponsored(\\n        Sponsorship memory sponsorship,\\n        bytes4 funcSignature,\\n        bytes memory encodedParams\\n    ) {\\n        _validateSponsorship(sponsorship, funcSignature, encodedParams);\\n        _paySponsor(\\n            sponsorship.sender,\\n            sponsorship.sponsor,\\n            sponsorship.sponsorFeeToken,\\n            sponsorship.sponsorFeeAmount\\n        );\\n        _;\\n    }\\n\\n    /**\\n        @dev Validates the signature of a meta-tx sponsorship, reverts if the signature is invalid.\\n        @param sponsorship The sponsorship information\\n        @param funcSignature The function signature (selector) of the function being called\\n        @param encodedParams The parameters of the function, encoded using abi.encode()\\n     */\\n    function _validateSponsorship(\\n        Sponsorship memory sponsorship,\\n        bytes4 funcSignature,\\n        bytes memory encodedParams\\n    ) internal virtual {\\n        require(\\n            sponsorship.nonce == accountNonce[sponsorship.sender],\\n            \\\"Sponsorable: BAD_NONCE\\\"\\n        );\\n        require(\\n            block.timestamp <= sponsorship.deadline,\\n            \\\"Sponsorable: SIG_DEAD\\\"\\n        );\\n\\n        uint256 chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n\\n        bytes32 digest =\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                    keccak256(\\n                        abi.encodePacked(\\n                            abi.encode(\\n                                chainId,\\n                                address(this),\\n                                sponsorship.sponsor,\\n                                sponsorship.sponsorFeeToken,\\n                                sponsorship.sponsorFeeAmount,\\n                                sponsorship.nonce,\\n                                sponsorship.deadline,\\n                                funcSignature\\n                            ),\\n                            encodedParams\\n                        )\\n                    )\\n                )\\n            );\\n\\n        address recoveredAddress =\\n            ECDSA.recover(\\n                digest,\\n                uint8(sponsorship.v),\\n                sponsorship.r,\\n                sponsorship.s\\n            );\\n        require(\\n            recoveredAddress != address(0) &&\\n                recoveredAddress == sponsorship.sender,\\n            \\\"Sponsorable: BAD_SIG\\\"\\n        );\\n\\n        // update nonce\\n        accountNonce[sponsorship.sender] = sponsorship.nonce + 1;\\n    }\\n\\n    /**\\n        @dev Transfers `sponsorFeeAmount` of ERC20 token `sponsorFeeToken` from `sender` to `sponsor`.\\n        @param sender The user who made the meta-tx\\n        @param sponsor The account that should receive the sponsor fee\\n        @param sponsorFeeToken The ERC20 token address the sponsor fee is paid in\\n        @param sponsorFeeAmount The amount of sponsor fee to transfer from `sender` to `sponsor`\\n     */\\n    function _paySponsor(\\n        address sender,\\n        address sponsor,\\n        address sponsorFeeToken,\\n        uint256 sponsorFeeAmount\\n    ) internal virtual {\\n        if (sponsorFeeAmount == 0) {\\n            return;\\n        }\\n\\n        IERC20 token = IERC20(sponsorFeeToken);\\n\\n        // transfer tokens from sender\\n        token.safeTransferFrom(sender, address(this), sponsorFeeAmount);\\n\\n        // transfer tokens to sponsor\\n        token.safeTransfer(sponsor, sponsorFeeAmount);\\n    }\\n\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0xec0182d5a00a558e469cbfb3dea0ee76a5fa77d4dc8061bf4789ca8d02037720\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libs/WrappedERC1155Token.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.3;\\n\\nimport {\\n    ClonesUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\\\";\\nimport {\\n    StringsUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\\\";\\nimport {ERC1155Upgradeable} from \\\"./ERC1155Upgradeable.sol\\\";\\nimport {ERC1155Base} from \\\"./ERC1155Base.sol\\\";\\nimport {ERC20Wrapper} from \\\"./ERC20Wrapper.sol\\\";\\n\\n/**\\n    @notice An ERC-1155 multitoken where each ID is wrapped in an ERC-20 interface\\n */\\nabstract contract WrappedERC1155Token is ERC1155Base {\\n    using ClonesUpgradeable for address;\\n    using StringsUpgradeable for uint256;\\n\\n    mapping(uint256 => address) public tokenIDToWrapper;\\n    address public wrapperTemplate;\\n    bool public deployWrapperOnMint;\\n    string public baseName;\\n    string public baseSymbol;\\n    uint8 public decimals;\\n\\n    function __WrappedERC1155Token_init(\\n        address admin,\\n        string memory uri,\\n        address _wrapperTemplate,\\n        bool _deployWrapperOnMint,\\n        string memory _baseName,\\n        string memory _baseSymbol,\\n        uint8 _decimals\\n    ) internal initializer {\\n        __ERC1155Base_init(admin, uri);\\n        __WrappedERC1155Token_init_unchained(\\n            _wrapperTemplate,\\n            _deployWrapperOnMint,\\n            _baseName,\\n            _baseSymbol,\\n            _decimals\\n        );\\n    }\\n\\n    function __WrappedERC1155Token_init_unchained(\\n        address _wrapperTemplate,\\n        bool _deployWrapperOnMint,\\n        string memory _baseName,\\n        string memory _baseSymbol,\\n        uint8 _decimals\\n    ) internal initializer {\\n        wrapperTemplate = _wrapperTemplate;\\n        deployWrapperOnMint = _deployWrapperOnMint;\\n        baseName = _baseName;\\n        baseSymbol = _baseSymbol;\\n        decimals = _decimals;\\n    }\\n\\n    /**\\n        @notice Called by an ERC20Wrapper contract to handle a transfer call.\\n        @dev Only callable by a wrapper deployed by this contract.\\n        @param from Source of transfer\\n        @param to Target of transfer\\n        @param tokenID The ERC-1155 token ID of the wrapper\\n        @param amount The amount to transfer\\n     */\\n    function wrapperTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenID,\\n        uint256 amount\\n    ) external {\\n        require(\\n            msg.sender == tokenIDToWrapper[tokenID],\\n            \\\"WrappedERC1155Token: not wrapper\\\"\\n        );\\n        _safeTransferFrom(from, to, tokenID, amount, bytes(\\\"\\\"));\\n    }\\n\\n    /**\\n        @notice Deploys an ERC20Wrapper contract for the ERC-1155 tokens with ID `tokenID`.\\n        @dev If a wrapper already exists for this tokenID, does nothing and returns the address\\n             of the existing wrapper.\\n        @param tokenID The ID of the token to wrap\\n        @return wrapperAddress The address of the wrapper\\n     */\\n    function deployWrapper(uint256 tokenID)\\n        external\\n        returns (address wrapperAddress)\\n    {\\n        return _deployWrapper(tokenID);\\n    }\\n\\n    /**\\n        @dev See {deployWrapper}\\n     */\\n    function _deployWrapper(uint256 tokenID)\\n        internal\\n        returns (address wrapperAddress)\\n    {\\n        wrapperAddress = tokenIDToWrapper[tokenID];\\n        if (wrapperAddress == address(0)) {\\n            // deploy wrapper\\n            ERC20Wrapper wrapper = ERC20Wrapper(wrapperTemplate.clone());\\n            string memory tokenIDString = tokenID.toString();\\n            string memory name =\\n                string(abi.encodePacked(baseName, tokenIDString));\\n            string memory symbol =\\n                string(abi.encodePacked(baseSymbol, tokenIDString));\\n            wrapper.initialize(address(this), tokenID, name, symbol, decimals);\\n            tokenIDToWrapper[tokenID] = address(wrapper);\\n        }\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        if (from == address(0)) {\\n            // Mint\\n            if (deployWrapperOnMint) {\\n                for (uint256 i = 0; i < ids.length; i++) {\\n                    _deployWrapper(ids[i]);\\n                }\\n            }\\n        }\\n\\n        // Emit transfer event in wrapper\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            address wrapperAddress = tokenIDToWrapper[ids[i]];\\n            if (wrapperAddress != address(0)) {\\n                ERC20Wrapper wrapper = ERC20Wrapper(wrapperAddress);\\n                wrapper.emitTransferEvent(from, to, amounts[i]);\\n            }\\n        }\\n    }\\n\\n    /**\\n        @dev See {ERC1155Upgradeable._shouldSkipSafeTransferAcceptanceCheck}\\n     */\\n    function _shouldSkipSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual override(ERC1155Upgradeable) returns (bool) {\\n        address wrapperAddress = tokenIDToWrapper[id];\\n        if (wrapperAddress != address(0)) {\\n            // has wrapper, check if operator is the wrapper\\n            return operator == wrapperAddress;\\n        } else {\\n            // no wrapper, should do safety checks\\n            return false;\\n        }\\n    }\\n\\n    /**\\n        Param setters (need metadata role)\\n     */\\n    function setDeployWrapperOnMint(bool newValue) external {\\n        require(\\n            hasRole(METADATA_ROLE, msg.sender),\\n            \\\"WrappedERC1155Token: no metadata role\\\"\\n        );\\n        deployWrapperOnMint = newValue;\\n    }\\n\\n    function setBaseName(string calldata newValue) external {\\n        require(\\n            hasRole(METADATA_ROLE, msg.sender),\\n            \\\"WrappedERC1155Token: no metadata role\\\"\\n        );\\n        baseName = newValue;\\n    }\\n\\n    function setBaseSymbol(string calldata newValue) external {\\n        require(\\n            hasRole(METADATA_ROLE, msg.sender),\\n            \\\"WrappedERC1155Token: no metadata role\\\"\\n        );\\n        baseSymbol = newValue;\\n    }\\n\\n    uint256[44] private __gap;\\n}\\n\",\"keccak256\":\"0xafaa1521698e4ec67ac1a37521736f3f8536e55fa4bb278a4441f419060a1a6d\",\"license\":\"GPL-3.0-or-later\"},\"contracts/models/fee/IFeeModel.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.3;\\n\\ninterface IFeeModel {\\n    function beneficiary() external view returns (address payable);\\n\\n    function getInterestFeeAmount(address pool, uint256 interestAmount)\\n        external\\n        view\\n        returns (uint256 feeAmount);\\n\\n    function getEarlyWithdrawFeeAmount(\\n        address pool,\\n        uint64 depositID,\\n        uint256 withdrawnDepositAmount\\n    ) external view returns (uint256 feeAmount);\\n}\\n\",\"keccak256\":\"0xe58d4e0e42103eb63c01bbfff816385ca3d8370fc6a3024726cd04f0d6e69e03\",\"license\":\"GPL-3.0-or-later\"},\"contracts/models/interest-oracle/IInterestOracle.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.3;\\n\\nimport {IMoneyMarket} from \\\"../../moneymarkets/IMoneyMarket.sol\\\";\\n\\ninterface IInterestOracle {\\n    function updateAndQuery() external returns (bool updated, uint256 value);\\n\\n    function query() external view returns (uint256 value);\\n\\n    function moneyMarket() external view returns (IMoneyMarket);\\n}\\n\",\"keccak256\":\"0xf71ebb170e65f17ce3470ada38969a5a97c45145faafead2575285e8b63984e2\",\"license\":\"GPL-3.0-or-later\"},\"contracts/models/interest/IInterestModel.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.3;\\n\\ninterface IInterestModel {\\n    function calculateInterestAmount(\\n        uint256 depositAmount,\\n        uint256 depositPeriodInSeconds,\\n        uint256 moneyMarketInterestRatePerSecond,\\n        bool surplusIsNegative,\\n        uint256 surplusAmount\\n    ) external view returns (uint256 interestAmount);\\n}\\n\",\"keccak256\":\"0xbdb2b0d689338683188ff2f54e4b77bd7f6a4ef284e0c15c88fedb4a07caca78\",\"license\":\"GPL-3.0-or-later\"},\"contracts/models/issuance/IMPHIssuanceModel.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.3;\\n\\ninterface IMPHIssuanceModel {\\n    /**\\n        v2 legacy functions\\n     */\\n    /**\\n        @notice Computes the MPH amount to reward to a depositor upon deposit.\\n        @param  pool The DInterest pool trying to mint reward\\n        @param  depositAmount The deposit amount in the pool's stablecoins\\n        @param  depositPeriodInSeconds The deposit's lock period in seconds\\n        @return depositorReward The MPH amount to mint to the depositor\\n                devReward The MPH amount to mint to the dev wallet\\n                govReward The MPH amount to mint to the gov treasury\\n     */\\n    function computeDepositorReward(\\n        address pool,\\n        uint256 depositAmount,\\n        uint256 depositPeriodInSeconds\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 depositorReward,\\n            uint256 devReward,\\n            uint256 govReward\\n        );\\n\\n    /**\\n        @notice Computes the MPH amount to take back from a depositor upon withdrawal.\\n                If takeBackAmount > devReward + govReward, the extra MPH should be burnt.\\n        @param  mintMPHAmount The MPH amount originally minted to the depositor as reward\\n        @param  early True if the deposit is withdrawn early, false if the deposit is mature\\n        @return takeBackAmount The MPH amount to take back from the depositor\\n                devReward The MPH amount from takeBackAmount to send to the dev wallet\\n                govReward The MPH amount from takeBackAmount to send to the gov treasury\\n     */\\n    function computeTakeBackDepositorRewardAmount(\\n        uint256 mintMPHAmount,\\n        bool early\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 takeBackAmount,\\n            uint256 devReward,\\n            uint256 govReward\\n        );\\n\\n    /**\\n        @notice Computes the MPH amount to reward to a deficit funder upon withdrawal of an underlying deposit.\\n        @param  pool The DInterest pool trying to mint reward\\n        @param  depositAmount The deposit amount in the pool's stablecoins\\n        @param  fundingCreationTimestamp The timestamp of the funding's creation, in seconds\\n        @param  maturationTimestamp The maturation timestamp of the deposit, in seconds\\n        @param  early True if the deposit is withdrawn early, false if the deposit is mature\\n        @return funderReward The MPH amount to mint to the funder\\n                devReward The MPH amount to mint to the dev wallet\\n                govReward The MPH amount to mint to the gov treasury\\n     */\\n    function computeFunderReward(\\n        address pool,\\n        uint256 depositAmount,\\n        uint256 fundingCreationTimestamp,\\n        uint64 maturationTimestamp,\\n        bool early\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 funderReward,\\n            uint256 devReward,\\n            uint256 govReward\\n        );\\n\\n    /**\\n        @notice The period over which the funder reward will be vested, in seconds.\\n     */\\n    function poolFunderRewardVestPeriod(address pool)\\n        external\\n        view\\n        returns (uint256 vestPeriodInSeconds);\\n\\n    /**\\n        v3 functions\\n     */\\n    /**\\n        @notice The multiplier applied when minting MPH for a pool's depositor reward.\\n                Unit is MPH-wei per depositToken-wei per second. (wei here is the smallest decimal place)\\n                Scaled by 10^18.\\n                NOTE: The depositToken's decimals matter!\\n     */\\n    function poolDepositorRewardMintMultiplier(address pool)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n        @notice The multiplier applied when minting MPH for a pool's funder reward.\\n                v2 usage:\\n                Unit is MPH-wei per depositToken-wei per second. (wei here is the smallest decimal place)\\n                Scaled by 10^18.\\n                NOTE: The depositToken's decimals matter!\\n                v3 usage:\\n                Unit is MPH-wei per depositToken-wei. (wei here is the smallest decimal place)\\n                Scaled by 10^18.\\n                NOTE: The depositToken's decimals matter!\\n     */\\n    function poolFunderRewardMultiplier(address pool)\\n        external\\n        view\\n        returns (uint256);\\n}\\n\",\"keccak256\":\"0x48fc3f18dd5bd813e795b22af71a6cafd69970526573c60fb441b52c00847eab\",\"license\":\"GPL-3.0-or-later\"},\"contracts/moneymarkets/IMoneyMarket.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.3;\\n\\nimport {ERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport {\\n    OwnableUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport {\\n    AccessControlUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\\\";\\nimport {Rescuable} from \\\"../libs/Rescuable.sol\\\";\\n\\n// Interface for money market protocols (Compound, Aave, etc.)\\nabstract contract IMoneyMarket is\\n    Rescuable,\\n    OwnableUpgradeable,\\n    AccessControlUpgradeable\\n{\\n    bytes32 internal constant RESCUER_ROLE = keccak256(\\\"RESCUER_ROLE\\\");\\n\\n    function __IMoneyMarket_init(address rescuer) internal initializer {\\n        __Ownable_init();\\n        __AccessControl_init();\\n\\n        // RESCUER_ROLE is managed by itself\\n        _setupRole(RESCUER_ROLE, rescuer);\\n        _setRoleAdmin(RESCUER_ROLE, RESCUER_ROLE);\\n    }\\n\\n    function deposit(uint256 amount) external virtual;\\n\\n    function withdraw(uint256 amountInUnderlying)\\n        external\\n        virtual\\n        returns (uint256 actualAmountWithdrawn);\\n\\n    function totalValue() external virtual returns (uint256); // The total value locked in the money market, in terms of the underlying stablecoin\\n\\n    function incomeIndex() external virtual returns (uint256); // Used for calculating the interest generated (e.g. cDai's price for the Compound market)\\n\\n    function stablecoin() external view virtual returns (ERC20);\\n\\n    function claimRewards() external virtual; // Claims farmed tokens (e.g. COMP, CRV) and sends it to the rewards pool\\n\\n    function setRewards(address newValue) external virtual;\\n\\n    /**\\n        @dev See {Rescuable._authorizeRescue}\\n     */\\n    function _authorizeRescue(\\n        address, /*token*/\\n        address /*target*/\\n    ) internal view virtual override {\\n        require(hasRole(RESCUER_ROLE, msg.sender), \\\"IMoneyMarket: not rescuer\\\");\\n    }\\n\\n    event ESetParamAddress(\\n        address indexed sender,\\n        string indexed paramName,\\n        address newValue\\n    );\\n}\\n\",\"keccak256\":\"0xa2316b5d54bb9ef302c511a4a2730db5f45acb84ac0e53131c4b3f258f2e14c2\",\"license\":\"GPL-3.0-or-later\"},\"contracts/rewards/MPHMinter.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.3;\\n\\nimport {\\n    AddressUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport {MPHMinterLegacy} from \\\"./MPHMinterLegacy.sol\\\";\\nimport {Vesting02} from \\\"./Vesting02.sol\\\";\\nimport {FundingMultitoken} from \\\"../tokens/FundingMultitoken.sol\\\";\\nimport {DecMath} from \\\"../libs/DecMath.sol\\\";\\nimport {DInterest} from \\\"../DInterest.sol\\\";\\n\\ncontract MPHMinter is MPHMinterLegacy {\\n    using AddressUpgradeable for address;\\n    using DecMath for uint256;\\n\\n    Vesting02 public vesting02;\\n\\n    function __MPHMinter_init(\\n        address _mph,\\n        address _govTreasury,\\n        address _devWallet,\\n        address _issuanceModel,\\n        address _vesting,\\n        address _vesting02\\n    ) internal initializer {\\n        __MPHMinterLegacy_init(\\n            _mph,\\n            _govTreasury,\\n            _devWallet,\\n            _issuanceModel,\\n            _vesting\\n        );\\n        __MPHMinter_init_unchained(_vesting02);\\n    }\\n\\n    function __MPHMinter_init_unchained(address _vesting02)\\n        internal\\n        initializer\\n    {\\n        vesting02 = Vesting02(_vesting02);\\n    }\\n\\n    function initialize(\\n        address _mph,\\n        address _govTreasury,\\n        address _devWallet,\\n        address _issuanceModel,\\n        address _vesting,\\n        address _vesting02\\n    ) external initializer {\\n        __MPHMinter_init(\\n            _mph,\\n            _govTreasury,\\n            _devWallet,\\n            _issuanceModel,\\n            _vesting,\\n            _vesting02\\n        );\\n    }\\n\\n    /**\\n        v3 functions\\n     */\\n    function createVestForDeposit(address account, uint64 depositID)\\n        external\\n        onlyRole(WHITELISTED_POOL_ROLE)\\n    {\\n        vesting02.createVestForDeposit(\\n            account,\\n            msg.sender,\\n            depositID,\\n            issuanceModel.poolDepositorRewardMintMultiplier(msg.sender)\\n        );\\n    }\\n\\n    function updateVestForDeposit(\\n        uint64 depositID,\\n        uint256 currentDepositAmount,\\n        uint256 depositAmount\\n    ) external onlyRole(WHITELISTED_POOL_ROLE) {\\n        vesting02.updateVestForDeposit(\\n            msg.sender,\\n            depositID,\\n            currentDepositAmount,\\n            depositAmount,\\n            issuanceModel.poolDepositorRewardMintMultiplier(msg.sender)\\n        );\\n    }\\n\\n    function mintVested(address account, uint256 amount)\\n        external\\n        returns (uint256 mintedAmount)\\n    {\\n        require(msg.sender == address(vesting02), \\\"MPHMinter: not vesting02\\\");\\n        if (mph.owner() != address(this)) {\\n            // not the owner of the MPH token, cannot mint\\n            return 0;\\n        }\\n        if (amount > 0) {\\n            mph.ownerMint(account, amount);\\n        }\\n        return amount;\\n    }\\n\\n    function distributeFundingRewards(uint64 fundingID, uint256 interestAmount)\\n        external\\n        onlyRole(WHITELISTED_POOL_ROLE)\\n    {\\n        if (interestAmount == 0 || mph.owner() != address(this)) {\\n            return;\\n        }\\n        uint256 mintMPHAmount =\\n            interestAmount.decmul(\\n                issuanceModel.poolFunderRewardMultiplier(msg.sender)\\n            );\\n        if (mintMPHAmount == 0) {\\n            return;\\n        }\\n        FundingMultitoken fundingMultitoken =\\n            DInterest(msg.sender).fundingMultitoken();\\n        mph.ownerMint(address(this), mintMPHAmount);\\n        mph.increaseAllowance(address(fundingMultitoken), mintMPHAmount);\\n        fundingMultitoken.distributeDividends(\\n            fundingID,\\n            address(mph),\\n            mintMPHAmount\\n        );\\n    }\\n\\n    /**\\n        Param setters\\n     */\\n    function setVesting02(address newValue)\\n        external\\n        onlyRole(DEFAULT_ADMIN_ROLE)\\n    {\\n        require(newValue.isContract(), \\\"MPHMinter: not contract\\\");\\n        vesting02 = Vesting02(newValue);\\n        emit ESetParamAddress(msg.sender, \\\"vesting02\\\", newValue);\\n    }\\n\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x750b9b1f3ed2d86c4c4a40775b150ff7e33a3cdf0e6161cbc9b336dcbeba4dd7\",\"license\":\"GPL-3.0-or-later\"},\"contracts/rewards/MPHMinterLegacy.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.3;\\n\\nimport {\\n    AccessControlUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\\\";\\nimport {\\n    AddressUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport {MPHToken} from \\\"./MPHToken.sol\\\";\\nimport {IMPHIssuanceModel} from \\\"../models/issuance/IMPHIssuanceModel.sol\\\";\\nimport {Vesting} from \\\"./Vesting.sol\\\";\\nimport {Vesting02} from \\\"./Vesting02.sol\\\";\\n\\ncontract MPHMinterLegacy is AccessControlUpgradeable {\\n    using AddressUpgradeable for address;\\n\\n    bytes32 public constant WHITELISTER_ROLE = keccak256(\\\"WHITELISTER_ROLE\\\");\\n    bytes32 public constant WHITELISTED_POOL_ROLE =\\n        keccak256(\\\"WHITELISTED_POOL_ROLE\\\");\\n\\n    event ESetParamAddress(\\n        address indexed sender,\\n        string indexed paramName,\\n        address newValue\\n    );\\n    event MintDepositorReward(\\n        address indexed sender,\\n        address indexed to,\\n        uint256 depositorReward\\n    );\\n    event TakeBackDepositorReward(\\n        address indexed sender,\\n        address indexed from,\\n        uint256 takeBackAmount\\n    );\\n    event MintFunderReward(\\n        address indexed sender,\\n        address indexed to,\\n        uint256 funderReward\\n    );\\n\\n    /**\\n        External contracts\\n     */\\n    MPHToken public mph;\\n    address public govTreasury;\\n    address public devWallet;\\n    IMPHIssuanceModel public issuanceModel;\\n    Vesting public vesting;\\n\\n    function __MPHMinterLegacy_init(\\n        address _mph,\\n        address _govTreasury,\\n        address _devWallet,\\n        address _issuanceModel,\\n        address _vesting\\n    ) internal initializer {\\n        __AccessControl_init();\\n        __MPHMinterLegacy_init_unchained(\\n            _mph,\\n            _govTreasury,\\n            _devWallet,\\n            _issuanceModel,\\n            _vesting\\n        );\\n    }\\n\\n    function __MPHMinterLegacy_init_unchained(\\n        address _mph,\\n        address _govTreasury,\\n        address _devWallet,\\n        address _issuanceModel,\\n        address _vesting\\n    ) internal initializer {\\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n        // only accounts with the whitelister role can whitelist pools\\n        _setRoleAdmin(WHITELISTED_POOL_ROLE, WHITELISTER_ROLE);\\n\\n        mph = MPHToken(_mph);\\n        govTreasury = _govTreasury;\\n        devWallet = _devWallet;\\n        issuanceModel = IMPHIssuanceModel(_issuanceModel);\\n        vesting = Vesting(_vesting);\\n    }\\n\\n    /**\\n        v2 legacy functions\\n     */\\n    /**\\n        @notice Mints the MPH reward to a depositor upon deposit.\\n        @param  to The depositor\\n        @param  depositAmount The deposit amount in the pool's stablecoins\\n        @param  depositPeriodInSeconds The deposit's lock period in seconds\\n        @param  interestAmount The deposit's fixed-rate interest amount in the pool's stablecoins\\n        @return depositorReward The MPH amount to mint to the depositor\\n     */\\n    function mintDepositorReward(\\n        address to,\\n        uint256 depositAmount,\\n        uint256 depositPeriodInSeconds,\\n        uint256 interestAmount\\n    ) external onlyRole(WHITELISTED_POOL_ROLE) returns (uint256) {\\n        if (mph.owner() != address(this)) {\\n            // not the owner of the MPH token, cannot mint\\n            emit MintDepositorReward(msg.sender, to, 0);\\n            return 0;\\n        }\\n\\n        (uint256 depositorReward, uint256 devReward, uint256 govReward) =\\n            issuanceModel.computeDepositorReward(\\n                msg.sender,\\n                depositAmount,\\n                depositPeriodInSeconds\\n            );\\n        if (depositorReward == 0 && devReward == 0 && govReward == 0) {\\n            return 0;\\n        }\\n\\n        // mint and vest depositor reward\\n        if (depositorReward > 0) {\\n            mph.ownerMint(address(this), depositorReward);\\n\\n            // vest the MPH to `to`\\n            mph.increaseAllowance(address(vesting), depositorReward);\\n            vesting.vest(to, depositorReward, depositPeriodInSeconds);\\n        }\\n        if (devReward > 0) {\\n            mph.ownerMint(devWallet, devReward);\\n        }\\n        if (govReward > 0) {\\n            mph.ownerMint(govTreasury, govReward);\\n        }\\n\\n        emit MintDepositorReward(msg.sender, to, depositorReward);\\n\\n        return depositorReward;\\n    }\\n\\n    /**\\n        @notice Takes back MPH from depositor upon withdrawal.\\n                If takeBackAmount > devReward + govReward, the extra MPH should be burnt.\\n        @param  from The depositor\\n        @param  mintMPHAmount The MPH amount originally minted to the depositor as reward\\n        @param  early True if the deposit is withdrawn early, false if the deposit is mature\\n        @return takeBackAmount The MPH amount to take back from the depositor\\n     */\\n    function takeBackDepositorReward(\\n        address from,\\n        uint256 mintMPHAmount,\\n        bool early\\n    ) external onlyRole(WHITELISTED_POOL_ROLE) returns (uint256) {\\n        (uint256 takeBackAmount, uint256 devReward, uint256 govReward) =\\n            issuanceModel.computeTakeBackDepositorRewardAmount(\\n                mintMPHAmount,\\n                early\\n            );\\n        if (takeBackAmount == 0 && devReward == 0 && govReward == 0) {\\n            return 0;\\n        }\\n        require(\\n            takeBackAmount >= devReward + govReward,\\n            \\\"MPHMinter: takeBackAmount < devReward + govReward\\\"\\n        );\\n        if (takeBackAmount > 0) {\\n            mph.transferFrom(from, address(this), takeBackAmount);\\n        }\\n        if (devReward > 0) {\\n            mph.transfer(devWallet, devReward);\\n        }\\n        if (govReward > 0) {\\n            mph.transfer(govTreasury, govReward);\\n        }\\n        uint256 remainder = takeBackAmount - devReward - govReward;\\n        if (remainder > 0) {\\n            mph.burn(remainder);\\n        }\\n\\n        emit TakeBackDepositorReward(msg.sender, from, takeBackAmount);\\n\\n        return takeBackAmount;\\n    }\\n\\n    /**\\n        @notice Mints the MPH reward to a deficit funder upon withdrawal of an underlying deposit.\\n        @param  to The funder\\n        @param  depositAmount The deposit amount in the pool's stablecoins\\n        @param  fundingCreationTimestamp The timestamp of the funding's creation, in seconds\\n        @param  maturationTimestamp The maturation timestamp of the deposit, in seconds\\n        @param  interestPayoutAmount The interest payout amount to the funder, in the pool's stablecoins.\\n                                     Includes the interest from other funded deposits.\\n        @param  early True if the deposit is withdrawn early, false if the deposit is mature\\n        @return funderReward The MPH amount to mint to the funder\\n     */\\n    function mintFunderReward(\\n        address to,\\n        uint256 depositAmount,\\n        uint256 fundingCreationTimestamp,\\n        uint64 maturationTimestamp,\\n        uint256 interestPayoutAmount,\\n        bool early\\n    ) external onlyRole(WHITELISTED_POOL_ROLE) returns (uint256) {\\n        if (mph.owner() != address(this)) {\\n            // not the owner of the MPH token, cannot mint\\n            emit MintDepositorReward(msg.sender, to, 0);\\n            return 0;\\n        }\\n\\n        (uint256 funderReward, uint256 devReward, uint256 govReward) =\\n            issuanceModel.computeFunderReward(\\n                msg.sender,\\n                depositAmount,\\n                fundingCreationTimestamp,\\n                maturationTimestamp,\\n                early\\n            );\\n        if (funderReward == 0 && devReward == 0 && govReward == 0) {\\n            return 0;\\n        }\\n\\n        // mint and vest funder reward\\n        if (funderReward > 0) {\\n            mph.ownerMint(address(this), funderReward);\\n            uint256 vestPeriodInSeconds =\\n                issuanceModel.poolFunderRewardVestPeriod(msg.sender);\\n            if (vestPeriodInSeconds == 0) {\\n                // no vesting, transfer to `to`\\n                mph.transfer(to, funderReward);\\n            } else {\\n                // vest the MPH to `to`\\n                mph.increaseAllowance(address(vesting), funderReward);\\n                vesting.vest(to, funderReward, vestPeriodInSeconds);\\n            }\\n        }\\n\\n        if (devReward > 0) {\\n            mph.ownerMint(devWallet, devReward);\\n        }\\n        if (govReward > 0) {\\n            mph.ownerMint(govTreasury, govReward);\\n        }\\n\\n        emit MintFunderReward(msg.sender, to, funderReward);\\n\\n        return funderReward;\\n    }\\n\\n    /**\\n        Param setters\\n     */\\n    function setGovTreasury(address newValue)\\n        external\\n        onlyRole(DEFAULT_ADMIN_ROLE)\\n    {\\n        require(newValue != address(0), \\\"MPHMinter: 0 address\\\");\\n        govTreasury = newValue;\\n        emit ESetParamAddress(msg.sender, \\\"govTreasury\\\", newValue);\\n    }\\n\\n    function setDevWallet(address newValue)\\n        external\\n        onlyRole(DEFAULT_ADMIN_ROLE)\\n    {\\n        require(newValue != address(0), \\\"MPHMinter: 0 address\\\");\\n        devWallet = newValue;\\n        emit ESetParamAddress(msg.sender, \\\"devWallet\\\", newValue);\\n    }\\n\\n    function setMPHTokenOwner(address newValue)\\n        external\\n        onlyRole(DEFAULT_ADMIN_ROLE)\\n    {\\n        require(newValue != address(0), \\\"MPHMinter: 0 address\\\");\\n        mph.transferOwnership(newValue);\\n        emit ESetParamAddress(msg.sender, \\\"mphTokenOwner\\\", newValue);\\n    }\\n\\n    function setMPHTokenOwnerToZero() external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        mph.renounceOwnership();\\n        emit ESetParamAddress(msg.sender, \\\"mphTokenOwner\\\", address(0));\\n    }\\n\\n    function setIssuanceModel(address newValue)\\n        external\\n        onlyRole(DEFAULT_ADMIN_ROLE)\\n    {\\n        require(newValue.isContract(), \\\"MPHMinter: not contract\\\");\\n        issuanceModel = IMPHIssuanceModel(newValue);\\n        emit ESetParamAddress(msg.sender, \\\"issuanceModel\\\", newValue);\\n    }\\n\\n    function setVesting(address newValue)\\n        external\\n        onlyRole(DEFAULT_ADMIN_ROLE)\\n    {\\n        require(newValue.isContract(), \\\"MPHMinter: not contract\\\");\\n        vesting = Vesting(newValue);\\n        emit ESetParamAddress(msg.sender, \\\"vesting\\\", newValue);\\n    }\\n\\n    uint256[45] private __gap;\\n}\\n\",\"keccak256\":\"0xac944309ab3b1a4b77a63c7f4537e5e00dc7f84a90c8018e85684896e3a9efe5\",\"license\":\"GPL-3.0-or-later\"},\"contracts/rewards/MPHToken.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.3;\\n\\nimport {\\n    ERC20Upgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\\\";\\nimport {\\n    ERC20BurnableUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\\\";\\nimport {\\n    OwnableUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\n\\ncontract MPHToken is\\n    ERC20Upgradeable,\\n    ERC20BurnableUpgradeable,\\n    OwnableUpgradeable\\n{\\n    function initialize() public initializer {\\n        __Ownable_init();\\n        __ERC20Burnable_init();\\n        __ERC20_init(\\\"88mph.app\\\", \\\"MPH\\\");\\n    }\\n\\n    function ownerMint(address account, uint256 amount)\\n        public\\n        onlyOwner\\n        returns (bool)\\n    {\\n        _mint(account, amount);\\n        return true;\\n    }\\n}\\n\",\"keccak256\":\"0x886edf4dac2bb99c9f5e8296f8daf910d20d14f51a61474bbd435689cbc684a2\",\"license\":\"GPL-3.0-or-later\"},\"contracts/rewards/Vesting.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.3;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"../libs/SafeERC20.sol\\\";\\n\\ncontract Vesting {\\n    using SafeERC20 for IERC20;\\n\\n    struct Vest {\\n        uint256 amount;\\n        uint256 vestPeriodInSeconds;\\n        uint256 creationTimestamp;\\n        uint256 withdrawnAmount;\\n    }\\n    mapping(address => Vest[]) public accountVestList;\\n\\n    IERC20 public token;\\n\\n    constructor(address _token) {\\n        token = IERC20(_token);\\n    }\\n\\n    function vest(\\n        address to,\\n        uint256 amount,\\n        uint256 vestPeriodInSeconds\\n    ) external returns (uint256 vestIdx) {\\n        require(vestPeriodInSeconds > 0, \\\"Vesting: vestPeriodInSeconds == 0\\\");\\n\\n        // transfer `amount` tokens from `msg.sender`\\n        token.safeTransferFrom(msg.sender, address(this), amount);\\n\\n        // create vest object\\n        vestIdx = accountVestList[to].length;\\n        accountVestList[to].push(\\n            Vest({\\n                amount: amount,\\n                vestPeriodInSeconds: vestPeriodInSeconds,\\n                creationTimestamp: block.timestamp,\\n                withdrawnAmount: 0\\n            })\\n        );\\n    }\\n\\n    function withdrawVested(address account, uint256 vestIdx)\\n        external\\n        returns (uint256 withdrawnAmount)\\n    {\\n        // compute withdrawable amount\\n        withdrawnAmount = _getVestWithdrawableAmount(account, vestIdx);\\n        if (withdrawnAmount == 0) {\\n            return 0;\\n        }\\n\\n        // update vest object\\n        uint256 recordedWithdrawnAmount =\\n            accountVestList[account][vestIdx].withdrawnAmount;\\n        accountVestList[account][vestIdx].withdrawnAmount =\\n            recordedWithdrawnAmount +\\n            withdrawnAmount;\\n\\n        // transfer tokens to vest recipient\\n        token.safeTransfer(account, withdrawnAmount);\\n    }\\n\\n    function getVestWithdrawableAmount(address account, uint256 vestIdx)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return _getVestWithdrawableAmount(account, vestIdx);\\n    }\\n\\n    function _getVestWithdrawableAmount(address account, uint256 vestIdx)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        // read vest data\\n        Vest storage vestObj = accountVestList[account][vestIdx];\\n        uint256 vestFullAmount = vestObj.amount;\\n        uint256 vestCreationTimestamp = vestObj.creationTimestamp;\\n        uint256 vestPeriodInSeconds = vestObj.vestPeriodInSeconds;\\n\\n        // compute vested amount\\n        uint256 vestedAmount;\\n        if (block.timestamp >= vestCreationTimestamp + vestPeriodInSeconds) {\\n            // vest period has passed, fully withdrawable\\n            vestedAmount = vestFullAmount;\\n        } else {\\n            // vest period has not passed, linearly unlock\\n            vestedAmount =\\n                (vestFullAmount * (block.timestamp - vestCreationTimestamp)) /\\n                vestPeriodInSeconds;\\n        }\\n\\n        // deduct already withdrawn amount and return\\n        return vestedAmount - vestObj.withdrawnAmount;\\n    }\\n}\\n\",\"keccak256\":\"0x5a54d6de7df290f3e602cc497cae2a6ea0fd47c72aaf597547dc6afdbf7673c9\",\"license\":\"GPL-3.0-or-later\"},\"contracts/rewards/Vesting02.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.3;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"../libs/SafeERC20.sol\\\";\\nimport {\\n    ERC721URIStorageUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol\\\";\\nimport {\\n    OwnableUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport {\\n    MathUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\\\";\\nimport {MPHMinter} from \\\"./MPHMinter.sol\\\";\\nimport {DInterest} from \\\"../DInterest.sol\\\";\\nimport {DecMath} from \\\"../libs/DecMath.sol\\\";\\n\\ncontract Vesting02 is ERC721URIStorageUpgradeable, OwnableUpgradeable {\\n    using SafeERC20 for IERC20;\\n    using DecMath for uint256;\\n\\n    uint256 internal constant PRECISION = 10**18;\\n\\n    struct Vest {\\n        address pool;\\n        uint64 depositID;\\n        uint64 lastUpdateTimestamp;\\n        uint256 accumulatedAmount;\\n        uint256 withdrawnAmount;\\n        uint256 vestAmountPerStablecoinPerSecond;\\n    }\\n    Vest[] public vestList;\\n    mapping(address => mapping(uint64 => uint64)) public depositIDToVestID;\\n\\n    MPHMinter public mphMinter;\\n    IERC20 public token;\\n    string internal _contractURI;\\n    string internal __baseURI;\\n\\n    event ECreateVest(\\n        address indexed to,\\n        address indexed pool,\\n        uint64 depositID,\\n        uint64 vestID,\\n        uint256 vestAmountPerStablecoinPerSecond\\n    );\\n    event EUpdateVest(uint64 indexed vestID);\\n    event EWithdraw(\\n        address indexed sender,\\n        uint64 indexed vestID,\\n        uint256 withdrawnAmount\\n    );\\n    event ESetMPHMinter(address newValue);\\n    event EBoost(\\n        uint64 indexed vestID,\\n        uint256 vestAmountPerStablecoinPerSecond\\n    );\\n\\n    function initialize(\\n        address _token,\\n        string calldata tokenName,\\n        string calldata tokenSymbol\\n    ) external initializer {\\n        __Ownable_init();\\n        __ERC721_init(tokenName, tokenSymbol);\\n\\n        token = IERC20(_token);\\n    }\\n\\n    function setMPHMinter(address newValue) external onlyOwner {\\n        require(newValue != address(0), \\\"Vesting02: 0 address\\\");\\n        mphMinter = MPHMinter(newValue);\\n        emit ESetMPHMinter(newValue);\\n    }\\n\\n    /**\\n        MPHMinter only functions\\n     */\\n\\n    function createVestForDeposit(\\n        address to,\\n        address pool,\\n        uint64 depositID,\\n        uint256 vestAmountPerStablecoinPerSecond\\n    ) external returns (uint64 vestID) {\\n        require(\\n            address(msg.sender) == address(mphMinter),\\n            \\\"Vesting02: not minter\\\"\\n        );\\n\\n        // create vest object\\n        vestList.push(\\n            Vest({\\n                pool: pool,\\n                depositID: depositID,\\n                lastUpdateTimestamp: uint64(block.timestamp),\\n                accumulatedAmount: 0,\\n                withdrawnAmount: 0,\\n                vestAmountPerStablecoinPerSecond: vestAmountPerStablecoinPerSecond\\n            })\\n        );\\n        vestID = uint64(vestList.length); // 1-indexed\\n        depositIDToVestID[pool][depositID] = vestID;\\n\\n        // mint NFT\\n        _safeMint(to, vestID);\\n\\n        emit ECreateVest(\\n            to,\\n            pool,\\n            depositID,\\n            vestID,\\n            vestAmountPerStablecoinPerSecond\\n        );\\n    }\\n\\n    function updateVestForDeposit(\\n        address pool,\\n        uint64 depositID,\\n        uint256 currentDepositAmount,\\n        uint256 depositAmount,\\n        uint256 vestAmountPerStablecoinPerSecond\\n    ) external {\\n        require(\\n            address(msg.sender) == address(mphMinter),\\n            \\\"Vesting02: not minter\\\"\\n        );\\n\\n        uint64 vestID = depositIDToVestID[pool][depositID];\\n        Vest storage vestEntry = _getVest(vestID);\\n        DInterest pool = DInterest(vestEntry.pool);\\n        DInterest.Deposit memory depositEntry =\\n            pool.getDeposit(vestEntry.depositID);\\n        uint256 currentTimestamp =\\n            MathUpgradeable.min(\\n                block.timestamp,\\n                depositEntry.maturationTimestamp\\n            );\\n        vestEntry.accumulatedAmount += (currentDepositAmount *\\n            (currentTimestamp - vestEntry.lastUpdateTimestamp))\\n            .decmul(vestEntry.vestAmountPerStablecoinPerSecond);\\n        vestEntry.lastUpdateTimestamp = uint64(block.timestamp);\\n        vestEntry.vestAmountPerStablecoinPerSecond =\\n            (vestEntry.vestAmountPerStablecoinPerSecond *\\n                currentDepositAmount +\\n                vestAmountPerStablecoinPerSecond *\\n                depositAmount) /\\n            (currentDepositAmount + depositAmount);\\n\\n        emit EUpdateVest(vestID);\\n    }\\n\\n    /**\\n        Public action functions\\n     */\\n\\n    function withdraw(uint64 vestID)\\n        external\\n        returns (uint256 withdrawnAmount)\\n    {\\n        require(ownerOf(vestID) == msg.sender, \\\"Vesting02: not owner\\\");\\n\\n        // compute withdrawable amount\\n        withdrawnAmount = _getVestWithdrawableAmount(vestID);\\n        if (withdrawnAmount == 0) {\\n            return 0;\\n        }\\n\\n        // update vest object\\n        Vest storage vestEntry = _getVest(vestID);\\n        vestEntry.withdrawnAmount += withdrawnAmount;\\n\\n        // mint tokens to vest recipient\\n        mphMinter.mintVested(msg.sender, withdrawnAmount);\\n\\n        emit EWithdraw(msg.sender, vestID, withdrawnAmount);\\n    }\\n\\n    /**\\n        Public getter functions\\n     */\\n\\n    function getVestWithdrawableAmount(uint64 vestID)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return _getVestWithdrawableAmount(vestID);\\n    }\\n\\n    function _getVestWithdrawableAmount(uint64 vestID)\\n        internal\\n        view\\n        returns (uint256 withdrawableAmount)\\n    {\\n        // read vest data\\n        Vest memory vestEntry = _getVest(vestID);\\n        DInterest pool = DInterest(vestEntry.pool);\\n        DInterest.Deposit memory depositEntry =\\n            pool.getDeposit(vestEntry.depositID);\\n\\n        // compute vested amount\\n        uint256 currentTimestamp =\\n            MathUpgradeable.min(\\n                block.timestamp,\\n                depositEntry.maturationTimestamp\\n            );\\n        if (currentTimestamp < vestEntry.lastUpdateTimestamp) {\\n            return vestEntry.accumulatedAmount - vestEntry.withdrawnAmount;\\n        }\\n        uint256 depositAmount =\\n            depositEntry.virtualTokenTotalSupply.decdiv(\\n                PRECISION + depositEntry.interestRate\\n            );\\n        return\\n            vestEntry.accumulatedAmount +\\n            (depositAmount * (currentTimestamp - vestEntry.lastUpdateTimestamp))\\n                .decmul(vestEntry.vestAmountPerStablecoinPerSecond) -\\n            vestEntry.withdrawnAmount;\\n    }\\n\\n    function getVest(uint64 vestID) external view returns (Vest memory) {\\n        return _getVest(vestID);\\n    }\\n\\n    function _getVest(uint64 vestID) internal view returns (Vest storage) {\\n        return vestList[vestID - 1];\\n    }\\n\\n    function numVests() external view returns (uint256) {\\n        return vestList.length;\\n    }\\n\\n    /**\\n        NFT metadata\\n     */\\n\\n    function contractURI() external view returns (string memory) {\\n        return _contractURI;\\n    }\\n\\n    function _baseURI() internal view override returns (string memory) {\\n        return __baseURI;\\n    }\\n\\n    function setContractURI(string calldata newURI) external onlyOwner {\\n        _contractURI = newURI;\\n    }\\n\\n    function setTokenURI(uint256 tokenId, string calldata newURI) external {\\n        require(ownerOf(tokenId) == msg.sender, \\\"Vesting02: not token owner\\\");\\n        _setTokenURI(tokenId, newURI);\\n    }\\n\\n    /**\\n        Owner functions\\n     */\\n\\n    function setBaseURI(string calldata newURI) external onlyOwner {\\n        __baseURI = newURI;\\n    }\\n\\n    function boost(uint64 vestID, uint256 vestAmountPerStablecoinPerSecond)\\n        external\\n        onlyOwner\\n    {\\n        _getVest(vestID)\\n            .vestAmountPerStablecoinPerSecond = vestAmountPerStablecoinPerSecond;\\n        emit EBoost(vestID, vestAmountPerStablecoinPerSecond);\\n    }\\n\\n    uint256[44] private __gap;\\n}\\n\",\"keccak256\":\"0xf1d00cdf4b369731be0967242a26cba07dd7f21099060cdf36bcb74a9a09c8a2\",\"license\":\"GPL-3.0-or-later\"},\"contracts/tokens/FundingMultitoken.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.3;\\n\\nimport {ERC1155Upgradeable} from \\\"../libs/ERC1155Upgradeable.sol\\\";\\nimport {ERC1155DividendToken} from \\\"../libs/ERC1155DividendToken.sol\\\";\\nimport {WrappedERC1155Token} from \\\"../libs/WrappedERC1155Token.sol\\\";\\n\\ncontract FundingMultitoken is ERC1155DividendToken, WrappedERC1155Token {\\n    bytes32 public constant DIVIDEND_ROLE = keccak256(\\\"DIVIDEND_ROLE\\\");\\n\\n    function __FundingMultitoken_init(\\n        address admin,\\n        string calldata uri,\\n        address[] memory dividendTokens,\\n        address _wrapperTemplate,\\n        bool _deployWrapperOnMint,\\n        string memory _baseName,\\n        string memory _baseSymbol,\\n        uint8 _decimals\\n    ) internal initializer {\\n        __ERC1155Base_init(admin, uri);\\n        __ERC1155DividendToken_init_unchained(dividendTokens);\\n        __WrappedERC1155Token_init_unchained(\\n            _wrapperTemplate,\\n            _deployWrapperOnMint,\\n            _baseName,\\n            _baseSymbol,\\n            _decimals\\n        );\\n        __FundingMultitoken_init_unchained(admin);\\n    }\\n\\n    function __FundingMultitoken_init_unchained(address admin)\\n        internal\\n        initializer\\n    {\\n        // DIVIDEND_ROLE is managed by itself\\n        _setupRole(DIVIDEND_ROLE, admin);\\n        _setRoleAdmin(DIVIDEND_ROLE, DIVIDEND_ROLE);\\n    }\\n\\n    function initialize(\\n        address admin,\\n        string calldata uri,\\n        address[] calldata dividendTokens,\\n        address _wrapperTemplate,\\n        bool _deployWrapperOnMint,\\n        string memory _baseName,\\n        string memory _baseSymbol,\\n        uint8 _decimals\\n    ) external virtual initializer {\\n        __FundingMultitoken_init(\\n            admin,\\n            uri,\\n            dividendTokens,\\n            _wrapperTemplate,\\n            _deployWrapperOnMint,\\n            _baseName,\\n            _baseSymbol,\\n            _decimals\\n        );\\n    }\\n\\n    function distributeDividends(\\n        uint256 tokenID,\\n        address dividendToken,\\n        uint256 amount\\n    ) external {\\n        require(\\n            hasRole(DIVIDEND_ROLE, _msgSender()),\\n            \\\"FundingMultitoken: must have dividend role\\\"\\n        );\\n        _distributeDividends(tokenID, dividendToken, amount);\\n    }\\n\\n    function withdrawDividend(uint256 tokenID, address dividendToken) external {\\n        _withdrawDividend(tokenID, dividendToken, msg.sender);\\n    }\\n\\n    function withdrawDividendFor(\\n        uint256 tokenID,\\n        address dividendToken,\\n        address user\\n    ) external {\\n        require(\\n            hasRole(DIVIDEND_ROLE, _msgSender()),\\n            \\\"FundingMultitoken: must have dividend role\\\"\\n        );\\n        _withdrawDividend(tokenID, dividendToken, user);\\n    }\\n\\n    function registerDividendToken(address dividendToken) external {\\n        require(\\n            hasRole(DIVIDEND_ROLE, _msgSender()),\\n            \\\"FundingMultitoken: must have dividend role\\\"\\n        );\\n        _registerDividendToken(dividendToken);\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual override(ERC1155DividendToken, WrappedERC1155Token) {\\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n        @dev See {ERC1155Upgradeable._shouldSkipSafeTransferAcceptanceCheck}\\n     */\\n    function _shouldSkipSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    )\\n        internal\\n        override(ERC1155Upgradeable, WrappedERC1155Token)\\n        returns (bool)\\n    {\\n        return\\n            WrappedERC1155Token._shouldSkipSafeTransferAcceptanceCheck(\\n                operator,\\n                from,\\n                to,\\n                id,\\n                amount,\\n                data\\n            );\\n    }\\n\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x152ab97dfe554e8809295073a6a6a1313bee0b18edfae83f995c86129ecd4867\",\"license\":\"GPL-3.0-or-later\"},\"contracts/tokens/NFT.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.3;\\n\\nimport {\\n    ERC721URIStorageUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol\\\";\\nimport {\\n    OwnableUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\n\\ncontract NFT is ERC721URIStorageUpgradeable, OwnableUpgradeable {\\n    string internal _contractURI;\\n    string internal __baseURI;\\n\\n    function initialize(string calldata tokenName, string calldata tokenSymbol)\\n        external\\n        initializer\\n    {\\n        __Ownable_init();\\n        __ERC721_init(tokenName, tokenSymbol);\\n    }\\n\\n    function contractURI() external view returns (string memory) {\\n        return _contractURI;\\n    }\\n\\n    function _baseURI() internal view override returns (string memory) {\\n        return __baseURI;\\n    }\\n\\n    function mint(address to, uint256 tokenId) external onlyOwner {\\n        _safeMint(to, tokenId);\\n    }\\n\\n    function burn(uint256 tokenId) external onlyOwner {\\n        _burn(tokenId);\\n    }\\n\\n    function setContractURI(string calldata newURI) external onlyOwner {\\n        _contractURI = newURI;\\n    }\\n\\n    function setTokenURI(uint256 tokenId, string calldata newURI) external {\\n        require(ownerOf(tokenId) == msg.sender, \\\"NFT: not token owner\\\");\\n        _setTokenURI(tokenId, newURI);\\n    }\\n\\n    function setBaseURI(string calldata newURI) external onlyOwner {\\n        __baseURI = newURI;\\n    }\\n\\n    uint256[48] private __gap;\\n}\\n\",\"keccak256\":\"0x6d0050d3b3e44fd32468a873006378622a3465107160a11e87114a0aa6e55be2\",\"license\":\"GPL-3.0-or-later\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x72b6a1d297cd3b033d7c2e4a7e7864934bb767db6453623f1c3082c6534547f4\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50612ca7806100206000396000f3fe608060405234801561001057600080fd5b50600436106101da5760003560e01c806365f5275a1161010457806391d14854116100a2578063b698bc8611610071578063b698bc861461041a578063cc2a9a5b1461042d578063d547741f14610440578063ff12673a14610453576101da565b806391d14854146103d957806393320226146103ec578063a217fddf146103ff578063abd1ebda14610407576101da565b8063780e2190116100de578063780e21901461038d57806388a42f22146103a05780638c65a588146103b35780638ea5220f146103c6576101da565b806365f5275a146103545780636f6ff3bc14610367578063747942141461037a576101da565b80632cba80501161017c5780634898328e1161014b5780634898328e146102fd578063570618e1146103125780635ba4106a1461033957806365c5ea9414610341576101da565b80632cba8050146102b15780632f2ff15d146102c457806336568abe146102d757806344c63eec146102ea576101da565b80631f53ac02116101b85780631f53ac021461022f57806320205e0a146102425780632304aa6114610255578063248a9ca314610280576101da565b806301ffc9a7146101df57806305f3c6ad146102075780631a3ee6b11461021c575b600080fd5b6101f26101ed366004612903565b610466565b60405190151581526020015b60405180910390f35b61021a6102153660046126bc565b61049d565b005b61021a61022a366004612873565b610555565b61021a61023d3660046126bc565b610698565b61021a6102503660046126bc565b6106ff565b609754610268906001600160a01b031681565b6040516001600160a01b0390911681526020016101fe565b6102a361028e3660046128c7565b60009081526065602052604090206001015490565b6040519081526020016101fe565b61021a6102bf3660046126bc565b610767565b61021a6102d23660046128df565b6107d3565b61021a6102e53660046128df565b6107fe565b609b54610268906001600160a01b031681565b6102a3600080516020612c5283398151915281565b6102a37f8619cecd8b9e095ab43867f5b69d492180450fe862e6b50bfbfb24b75dd84c8a81565b61021a61087c565b6102a361034f3660046127a0565b610950565b60c954610268906001600160a01b031681565b61021a6103753660046126bc565b610d17565b6102a3610388366004612775565b610d7d565b609a54610268906001600160a01b031681565b61021a6103ae3660046129a9565b610efe565b61021a6103c13660046126bc565b61102a565b609954610268906001600160a01b031681565b6101f26103e73660046128df565b6110db565b61021a6103fa36600461298c565b611106565b6102a3600081565b6102a361041536600461281b565b611449565b6102a36104283660046127e1565b611a30565b61021a61043b3660046126f4565b611eee565b61021a61044e3660046128df565b611f6e565b609854610268906001600160a01b031681565b60006001600160e01b03198216637965db0b60e01b148061049757506301ffc9a760e01b6001600160e01b03198316145b92915050565b60006104aa81335b611f94565b6001600160a01b0382166104d95760405162461bcd60e51b81526004016104d090612ad5565b60405180910390fd5b609880546001600160a01b0319166001600160a01b0384161790556040516a676f76547265617375727960a81b8152600b015b6040519081900381206001600160a01b03841682529033907f64b03eb8356730cffd396927eec0e9b1e0599498960e022df3dae35791c17cf59060200160405180910390a35050565b600080516020612c5283398151915261056e81336104a5565b60c954609a5460405163a4a6b0c360e01b815233600482018190526001600160a01b0393841693638185772193889388929091169063a4a6b0c39060240160206040518083038186803b1580156105c457600080fd5b505afa1580156105d8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105fc919061292b565b6040516001600160e01b031960e087901b1681526001600160a01b03948516600482015293909216602484015267ffffffffffffffff1660448301526064820152608401602060405180830381600087803b15801561065a57600080fd5b505af115801561066e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106929190612970565b50505050565b60006106a481336104a5565b6001600160a01b0382166106ca5760405162461bcd60e51b81526004016104d090612ad5565b609980546001600160a01b0319166001600160a01b0384161790556040516819195d95d85b1b195d60ba1b815260090161050c565b600061070b81336104a5565b6001600160a01b0382163b6107325760405162461bcd60e51b81526004016104d090612a9e565b60c980546001600160a01b0319166001600160a01b038416179055604051683b32b9ba34b733981960b91b815260090161050c565b600061077381336104a5565b6001600160a01b0382163b61079a5760405162461bcd60e51b81526004016104d090612a9e565b609a80546001600160a01b0319166001600160a01b0384161790556040516c1a5cdcdd585b98d9535bd9195b609a1b8152600d0161050c565b6000828152606560205260409020600101546107ef81336104a5565b6107f98383611ff8565b505050565b6001600160a01b038116331461086e5760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201526e103937b632b9903337b91039b2b63360891b60648201526084016104d0565b610878828261207e565b5050565b600061088881336104a5565b609760009054906101000a90046001600160a01b03166001600160a01b031663715018a66040518163ffffffff1660e01b8152600401600060405180830381600087803b1580156108d857600080fd5b505af11580156108ec573d6000803e3d6000fd5b50505050604051610910906c36b8342a37b5b2b727bbb732b960991b8152600d0190565b604051908190038120600082529033907f64b03eb8356730cffd396927eec0e9b1e0599498960e022df3dae35791c17cf59060200160405180910390a350565b6000600080516020612c5283398151915261096b81336104a5565b609a54604051630243810560e61b8152600481018690528415156024820152600091829182916001600160a01b0316906390e041409060440160606040518083038186803b1580156109bc57600080fd5b505afa1580156109d0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109f49190612943565b925092509250826000148015610a08575081155b8015610a12575080155b15610a235760009450505050610d0f565b610a2d8183612b51565b831015610a965760405162461bcd60e51b815260206004820152603160248201527f4d50484d696e7465723a2074616b654261636b416d6f756e74203c2064657652604482015270195dd85c99080ac819dbdd94995dd85c99607a1b60648201526084016104d0565b8215610b2a576097546040516323b872dd60e01b81526001600160a01b038a8116600483015230602483015260448201869052909116906323b872dd90606401602060405180830381600087803b158015610af057600080fd5b505af1158015610b04573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b2891906128ab565b505b8115610bba5760975460995460405163a9059cbb60e01b81526001600160a01b039283169263a9059cbb92610b66929116908690600401612a52565b602060405180830381600087803b158015610b8057600080fd5b505af1158015610b94573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bb891906128ab565b505b8015610c4a5760975460985460405163a9059cbb60e01b81526001600160a01b039283169263a9059cbb92610bf6929116908590600401612a52565b602060405180830381600087803b158015610c1057600080fd5b505af1158015610c24573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c4891906128ab565b505b600081610c578486612ba8565b610c619190612ba8565b90508015610cc857609754604051630852cd8d60e31b8152600481018390526001600160a01b03909116906342966c6890602401600060405180830381600087803b158015610caf57600080fd5b505af1158015610cc3573d6000803e3d6000fd5b505050505b6040518481526001600160a01b038a169033907f2a4031f1dba0999413c3353ef734f98a377ecca64ba5fb8ad571363a468719849060200160405180910390a35091935050505b509392505050565b6000610d2381336104a5565b6001600160a01b0382163b610d4a5760405162461bcd60e51b81526004016104d090612a9e565b609b80546001600160a01b0319166001600160a01b0384161790556040516676657374696e6760c81b815260070161050c565b60c9546000906001600160a01b03163314610dda5760405162461bcd60e51b815260206004820152601860248201527f4d50484d696e7465723a206e6f742076657374696e673032000000000000000060448201526064016104d0565b60975460408051638da5cb5b60e01b8152905130926001600160a01b031691638da5cb5b916004808301926020929190829003018186803b158015610e1e57600080fd5b505afa158015610e32573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e5691906126d8565b6001600160a01b031614610e6c57506000610497565b8115610ef857609754604051631212e5cf60e21b81526001600160a01b039091169063484b973c90610ea49086908690600401612a52565b602060405180830381600087803b158015610ebe57600080fd5b505af1158015610ed2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ef691906128ab565b505b50919050565b600080516020612c52833981519152610f1781336104a5565b60c954609a5460405163a4a6b0c360e01b815233600482018190526001600160a01b0393841693634b0f59da93919289928992899291169063a4a6b0c39060240160206040518083038186803b158015610f7057600080fd5b505afa158015610f84573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fa8919061292b565b6040516001600160e01b031960e088901b1681526001600160a01b03909516600486015267ffffffffffffffff909316602485015260448401919091526064830152608482015260a401600060405180830381600087803b15801561100c57600080fd5b505af1158015611020573d6000803e3d6000fd5b5050505050505050565b600061103681336104a5565b6001600160a01b03821661105c5760405162461bcd60e51b81526004016104d090612ad5565b60975460405163f2fde38b60e01b81526001600160a01b0384811660048301529091169063f2fde38b90602401600060405180830381600087803b1580156110a357600080fd5b505af11580156110b7573d6000803e3d6000fd5b5050505060405161050c906c36b8342a37b5b2b727bbb732b960991b8152600d0190565b60009182526065602090815260408084206001600160a01b0393909316845291905290205460ff1690565b600080516020612c5283398151915261111f81336104a5565b8115806111af575060975460408051638da5cb5b60e01b8152905130926001600160a01b031691638da5cb5b916004808301926020929190829003018186803b15801561116b57600080fd5b505afa15801561117f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111a391906126d8565b6001600160a01b031614155b156111b9576107f9565b609a54604051628b3fe360e21b8152336004820152600091611241916001600160a01b039091169063022cff8c9060240160206040518083038186803b15801561120257600080fd5b505afa158015611216573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061123a919061292b565b84906120e5565b90508061124e57506107f9565b6000336001600160a01b0316635dc05d7f6040518163ffffffff1660e01b815260040160206040518083038186803b15801561128957600080fd5b505afa15801561129d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112c191906126d8565b609754604051631212e5cf60e21b81529192506001600160a01b03169063484b973c906112f49030908690600401612a52565b602060405180830381600087803b15801561130e57600080fd5b505af1158015611322573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061134691906128ab565b50609754604051633950935160e01b81526001600160a01b03909116906339509351906113799084908690600401612a52565b602060405180830381600087803b15801561139357600080fd5b505af11580156113a7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113cb91906128ab565b506097546040516316f6849d60e31b815267ffffffffffffffff871660048201526001600160a01b039182166024820152604481018490529082169063b7b424e890606401600060405180830381600087803b15801561142a57600080fd5b505af115801561143e573d6000803e3d6000fd5b505050505050505050565b6000600080516020612c5283398151915261146481336104a5565b60975460408051638da5cb5b60e01b8152905130926001600160a01b031691638da5cb5b916004808301926020929190829003018186803b1580156114a857600080fd5b505afa1580156114bc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114e091906126d8565b6001600160a01b03161461153857604051600081526001600160a01b0389169033907f8470ffe62d01bbd3da3613a0ca568a59e55b5a5730b74902038057d76b17d85c9060200160405180910390a360009150611a25565b609a5460405163f422eb9160e01b8152336004820152602481018990526044810188905267ffffffffffffffff871660648201528415156084820152600091829182916001600160a01b03169063f422eb919060a40160606040518083038186803b1580156115a657600080fd5b505afa1580156115ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115de9190612943565b9250925092508260001480156115f2575081155b80156115fc575080155b1561160d5760009450505050611a25565b82156118bf57609754604051631212e5cf60e21b81526001600160a01b039091169063484b973c906116459030908790600401612a52565b602060405180830381600087803b15801561165f57600080fd5b505af1158015611673573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061169791906128ab565b50609a5460405163f3eaeb2f60e01b81523360048201526000916001600160a01b03169063f3eaeb2f9060240160206040518083038186803b1580156116dc57600080fd5b505afa1580156116f0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611714919061292b565b9050806117a55760975460405163a9059cbb60e01b81526001600160a01b039091169063a9059cbb9061174d908f908890600401612a52565b602060405180830381600087803b15801561176757600080fd5b505af115801561177b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061179f91906128ab565b506118bd565b609754609b54604051633950935160e01b81526001600160a01b03928316926339509351926117db929116908890600401612a52565b602060405180830381600087803b1580156117f557600080fd5b505af1158015611809573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061182d91906128ab565b50609b546040516302546de160e41b81526001600160a01b038e81166004830152602482018790526044820184905290911690632546de1090606401602060405180830381600087803b15801561188357600080fd5b505af1158015611897573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118bb919061292b565b505b505b811561194f57609754609954604051631212e5cf60e21b81526001600160a01b039283169263484b973c926118fb929116908690600401612a52565b602060405180830381600087803b15801561191557600080fd5b505af1158015611929573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061194d91906128ab565b505b80156119df57609754609854604051631212e5cf60e21b81526001600160a01b039283169263484b973c9261198b929116908590600401612a52565b602060405180830381600087803b1580156119a557600080fd5b505af11580156119b9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119dd91906128ab565b505b6040518381526001600160a01b038c169033907f6814fdc7e44c7ca332752017eb98f9f3c76906682cbcb81cb9a712ad3c87dc719060200160405180910390a350909250505b509695505050505050565b6000600080516020612c52833981519152611a4b81336104a5565b60975460408051638da5cb5b60e01b8152905130926001600160a01b031691638da5cb5b916004808301926020929190829003018186803b158015611a8f57600080fd5b505afa158015611aa3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ac791906126d8565b6001600160a01b031614611b1f57604051600081526001600160a01b0387169033907f8470ffe62d01bbd3da3613a0ca568a59e55b5a5730b74902038057d76b17d85c9060200160405180910390a360009150611ee5565b609a5460405163d2a974db60e01b81523360048201526024810187905260448101869052600091829182916001600160a01b03169063d2a974db9060640160606040518083038186803b158015611b7557600080fd5b505afa158015611b89573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611bad9190612943565b925092509250826000148015611bc1575081155b8015611bcb575080155b15611bdc5760009450505050611ee5565b8215611d7f57609754604051631212e5cf60e21b81526001600160a01b039091169063484b973c90611c149030908790600401612a52565b602060405180830381600087803b158015611c2e57600080fd5b505af1158015611c42573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c6691906128ab565b50609754609b54604051633950935160e01b81526001600160a01b0392831692633950935192611c9d929116908790600401612a52565b602060405180830381600087803b158015611cb757600080fd5b505af1158015611ccb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611cef91906128ab565b50609b546040516302546de160e41b81526001600160a01b038b8116600483015260248201869052604482018a905290911690632546de1090606401602060405180830381600087803b158015611d4557600080fd5b505af1158015611d59573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d7d919061292b565b505b8115611e0f57609754609954604051631212e5cf60e21b81526001600160a01b039283169263484b973c92611dbb929116908690600401612a52565b602060405180830381600087803b158015611dd557600080fd5b505af1158015611de9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e0d91906128ab565b505b8015611e9f57609754609854604051631212e5cf60e21b81526001600160a01b039283169263484b973c92611e4b929116908590600401612a52565b602060405180830381600087803b158015611e6557600080fd5b505af1158015611e79573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e9d91906128ab565b505b6040518381526001600160a01b038a169033907f8470ffe62d01bbd3da3613a0ca568a59e55b5a5730b74902038057d76b17d85c9060200160405180910390a350909250505b50949350505050565b600054610100900460ff1680611f07575060005460ff16155b611f235760405162461bcd60e51b81526004016104d090612b03565b600054610100900460ff16158015611f45576000805461ffff19166101011790555b611f5387878787878761210b565b8015611f65576000805461ff00191690555b50505050505050565b600082815260656020526040902060010154611f8a81336104a5565b6107f9838361207e565b611f9e82826110db565b61087857611fb6816001600160a01b03166014612178565b611fc1836020612178565b604051602001611fd29291906129dd565b60408051601f198184030181529082905262461bcd60e51b82526104d091600401612a6b565b61200282826110db565b6108785760008281526065602090815260408083206001600160a01b03851684529091529020805460ff1916600117905561203a3390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b61208882826110db565b156108785760008281526065602090815260408083206001600160a01b0385168085529252808320805460ff1916905551339285917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45050565b6000670de0b6b3a76400006120fa8385612b89565b6121049190612b69565b9392505050565b600054610100900460ff1680612124575060005460ff16155b6121405760405162461bcd60e51b81526004016104d090612b03565b600054610100900460ff16158015612162576000805461ffff19166101011790555b61216f878787878761235a565b611f53826123e0565b60606000612187836002612b89565b612192906002612b51565b67ffffffffffffffff8111156121b857634e487b7160e01b600052604160045260246000fd5b6040519080825280601f01601f1916602001820160405280156121e2576020820181803683370190505b509050600360fc1b8160008151811061220b57634e487b7160e01b600052603260045260246000fd5b60200101906001600160f81b031916908160001a905350600f60fb1b8160018151811061224857634e487b7160e01b600052603260045260246000fd5b60200101906001600160f81b031916908160001a905350600061226c846002612b89565b612277906001612b51565b90505b600181111561230b576f181899199a1a9b1b9c1cb0b131b232b360811b85600f16601081106122b957634e487b7160e01b600052603260045260246000fd5b1a60f81b8282815181106122dd57634e487b7160e01b600052603260045260246000fd5b60200101906001600160f81b031916908160001a90535060049490941c9361230481612beb565b905061227a565b5083156121045760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e7460448201526064016104d0565b600054610100900460ff1680612373575060005460ff16155b61238f5760405162461bcd60e51b81526004016104d090612b03565b600054610100900460ff161580156123b1576000805461ffff19166101011790555b6123b9612467565b6123c686868686866124eb565b80156123d8576000805461ff00191690555b505050505050565b600054610100900460ff16806123f9575060005460ff16155b6124155760405162461bcd60e51b81526004016104d090612b03565b600054610100900460ff16158015612437576000805461ffff19166101011790555b60c980546001600160a01b0319166001600160a01b0384161790558015610878576000805461ff00191690555050565b600054610100900460ff1680612480575060005460ff16155b61249c5760405162461bcd60e51b81526004016104d090612b03565b600054610100900460ff161580156124be576000805461ffff19166101011790555b6124c66125f4565b6124ce6125f4565b6124d66125f4565b80156124e8576000805461ff00191690555b50565b600054610100900460ff1680612504575060005460ff16155b6125205760405162461bcd60e51b81526004016104d090612b03565b600054610100900460ff16158015612542576000805461ffff19166101011790555b61254d60003361265e565b612585600080516020612c528339815191527f8619cecd8b9e095ab43867f5b69d492180450fe862e6b50bfbfb24b75dd84c8a612668565b609780546001600160a01b03199081166001600160a01b0389811691909117909255609880548216888416179055609980548216878416179055609a80548216868416179055609b805490911691841691909117905580156123d8576000805461ff0019169055505050505050565b600054610100900460ff168061260d575060005460ff16155b6126295760405162461bcd60e51b81526004016104d090612b03565b600054610100900460ff161580156124d6576000805461ffff191661010117905580156124e8576000805461ff001916905550565b6108788282611ff8565b600082815260656020526040902060010154819060405184907fbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff90600090a460009182526065602052604090912060010155565b6000602082840312156126cd578081fd5b813561210481612c18565b6000602082840312156126e9578081fd5b815161210481612c18565b60008060008060008060c0878903121561270c578182fd5b863561271781612c18565b9550602087013561272781612c18565b9450604087013561273781612c18565b9350606087013561274781612c18565b9250608087013561275781612c18565b915060a087013561276781612c18565b809150509295509295509295565b60008060408385031215612787578182fd5b823561279281612c18565b946020939093013593505050565b6000806000606084860312156127b4578283fd5b83356127bf81612c18565b92506020840135915060408401356127d681612c2d565b809150509250925092565b600080600080608085870312156127f6578384fd5b843561280181612c18565b966020860135965060408601359560600135945092505050565b60008060008060008060c08789031215612833578182fd5b863561283e81612c18565b95506020870135945060408701359350606087013561285c81612c3b565b92506080870135915060a087013561276781612c2d565b60008060408385031215612885578182fd5b823561289081612c18565b915060208301356128a081612c3b565b809150509250929050565b6000602082840312156128bc578081fd5b815161210481612c2d565b6000602082840312156128d8578081fd5b5035919050565b600080604083850312156128f1578081fd5b8235915060208301356128a081612c18565b600060208284031215612914578081fd5b81356001600160e01b031981168114612104578182fd5b60006020828403121561293c578081fd5b5051919050565b600080600060608486031215612957578081fd5b8351925060208401519150604084015190509250925092565b600060208284031215612981578081fd5b815161210481612c3b565b6000806040838503121561299e578182fd5b823561279281612c3b565b6000806000606084860312156129bd578081fd5b83356129c881612c3b565b95602085013595506040909401359392505050565b60007f416363657373436f6e74726f6c3a206163636f756e742000000000000000000082528351612a15816017850160208801612bbf565b7001034b99036b4b9b9b4b733903937b6329607d1b6017918401918201528351612a46816028840160208801612bbf565b01602801949350505050565b6001600160a01b03929092168252602082015260400190565b6000602082528251806020840152612a8a816040850160208701612bbf565b601f01601f19169190910160400192915050565b60208082526017908201527f4d50484d696e7465723a206e6f7420636f6e7472616374000000000000000000604082015260600190565b6020808252601490820152734d50484d696e7465723a2030206164647265737360601b604082015260600190565b6020808252602e908201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160408201526d191e481a5b9a5d1a585b1a5e995960921b606082015260800190565b60008219821115612b6457612b64612c02565b500190565b600082612b8457634e487b7160e01b81526012600452602481fd5b500490565b6000816000190483118215151615612ba357612ba3612c02565b500290565b600082821015612bba57612bba612c02565b500390565b60005b83811015612bda578181015183820152602001612bc2565b838111156106925750506000910152565b600081612bfa57612bfa612c02565b506000190190565b634e487b7160e01b600052601160045260246000fd5b6001600160a01b03811681146124e857600080fd5b80151581146124e857600080fd5b67ffffffffffffffff811681146124e857600080fdfe01929b51ccb866359f22f5a3ce5c78c9fc36c4de9719e0e678f9a41b4e88b733a2646970667358221220e729d3f6f714735593b0b959cc7d860e3f7d3728ff70f4e31010dede4cb1a1d564736f6c63430008030033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101da5760003560e01c806365f5275a1161010457806391d14854116100a2578063b698bc8611610071578063b698bc861461041a578063cc2a9a5b1461042d578063d547741f14610440578063ff12673a14610453576101da565b806391d14854146103d957806393320226146103ec578063a217fddf146103ff578063abd1ebda14610407576101da565b8063780e2190116100de578063780e21901461038d57806388a42f22146103a05780638c65a588146103b35780638ea5220f146103c6576101da565b806365f5275a146103545780636f6ff3bc14610367578063747942141461037a576101da565b80632cba80501161017c5780634898328e1161014b5780634898328e146102fd578063570618e1146103125780635ba4106a1461033957806365c5ea9414610341576101da565b80632cba8050146102b15780632f2ff15d146102c457806336568abe146102d757806344c63eec146102ea576101da565b80631f53ac02116101b85780631f53ac021461022f57806320205e0a146102425780632304aa6114610255578063248a9ca314610280576101da565b806301ffc9a7146101df57806305f3c6ad146102075780631a3ee6b11461021c575b600080fd5b6101f26101ed366004612903565b610466565b60405190151581526020015b60405180910390f35b61021a6102153660046126bc565b61049d565b005b61021a61022a366004612873565b610555565b61021a61023d3660046126bc565b610698565b61021a6102503660046126bc565b6106ff565b609754610268906001600160a01b031681565b6040516001600160a01b0390911681526020016101fe565b6102a361028e3660046128c7565b60009081526065602052604090206001015490565b6040519081526020016101fe565b61021a6102bf3660046126bc565b610767565b61021a6102d23660046128df565b6107d3565b61021a6102e53660046128df565b6107fe565b609b54610268906001600160a01b031681565b6102a3600080516020612c5283398151915281565b6102a37f8619cecd8b9e095ab43867f5b69d492180450fe862e6b50bfbfb24b75dd84c8a81565b61021a61087c565b6102a361034f3660046127a0565b610950565b60c954610268906001600160a01b031681565b61021a6103753660046126bc565b610d17565b6102a3610388366004612775565b610d7d565b609a54610268906001600160a01b031681565b61021a6103ae3660046129a9565b610efe565b61021a6103c13660046126bc565b61102a565b609954610268906001600160a01b031681565b6101f26103e73660046128df565b6110db565b61021a6103fa36600461298c565b611106565b6102a3600081565b6102a361041536600461281b565b611449565b6102a36104283660046127e1565b611a30565b61021a61043b3660046126f4565b611eee565b61021a61044e3660046128df565b611f6e565b609854610268906001600160a01b031681565b60006001600160e01b03198216637965db0b60e01b148061049757506301ffc9a760e01b6001600160e01b03198316145b92915050565b60006104aa81335b611f94565b6001600160a01b0382166104d95760405162461bcd60e51b81526004016104d090612ad5565b60405180910390fd5b609880546001600160a01b0319166001600160a01b0384161790556040516a676f76547265617375727960a81b8152600b015b6040519081900381206001600160a01b03841682529033907f64b03eb8356730cffd396927eec0e9b1e0599498960e022df3dae35791c17cf59060200160405180910390a35050565b600080516020612c5283398151915261056e81336104a5565b60c954609a5460405163a4a6b0c360e01b815233600482018190526001600160a01b0393841693638185772193889388929091169063a4a6b0c39060240160206040518083038186803b1580156105c457600080fd5b505afa1580156105d8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105fc919061292b565b6040516001600160e01b031960e087901b1681526001600160a01b03948516600482015293909216602484015267ffffffffffffffff1660448301526064820152608401602060405180830381600087803b15801561065a57600080fd5b505af115801561066e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106929190612970565b50505050565b60006106a481336104a5565b6001600160a01b0382166106ca5760405162461bcd60e51b81526004016104d090612ad5565b609980546001600160a01b0319166001600160a01b0384161790556040516819195d95d85b1b195d60ba1b815260090161050c565b600061070b81336104a5565b6001600160a01b0382163b6107325760405162461bcd60e51b81526004016104d090612a9e565b60c980546001600160a01b0319166001600160a01b038416179055604051683b32b9ba34b733981960b91b815260090161050c565b600061077381336104a5565b6001600160a01b0382163b61079a5760405162461bcd60e51b81526004016104d090612a9e565b609a80546001600160a01b0319166001600160a01b0384161790556040516c1a5cdcdd585b98d9535bd9195b609a1b8152600d0161050c565b6000828152606560205260409020600101546107ef81336104a5565b6107f98383611ff8565b505050565b6001600160a01b038116331461086e5760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201526e103937b632b9903337b91039b2b63360891b60648201526084016104d0565b610878828261207e565b5050565b600061088881336104a5565b609760009054906101000a90046001600160a01b03166001600160a01b031663715018a66040518163ffffffff1660e01b8152600401600060405180830381600087803b1580156108d857600080fd5b505af11580156108ec573d6000803e3d6000fd5b50505050604051610910906c36b8342a37b5b2b727bbb732b960991b8152600d0190565b604051908190038120600082529033907f64b03eb8356730cffd396927eec0e9b1e0599498960e022df3dae35791c17cf59060200160405180910390a350565b6000600080516020612c5283398151915261096b81336104a5565b609a54604051630243810560e61b8152600481018690528415156024820152600091829182916001600160a01b0316906390e041409060440160606040518083038186803b1580156109bc57600080fd5b505afa1580156109d0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109f49190612943565b925092509250826000148015610a08575081155b8015610a12575080155b15610a235760009450505050610d0f565b610a2d8183612b51565b831015610a965760405162461bcd60e51b815260206004820152603160248201527f4d50484d696e7465723a2074616b654261636b416d6f756e74203c2064657652604482015270195dd85c99080ac819dbdd94995dd85c99607a1b60648201526084016104d0565b8215610b2a576097546040516323b872dd60e01b81526001600160a01b038a8116600483015230602483015260448201869052909116906323b872dd90606401602060405180830381600087803b158015610af057600080fd5b505af1158015610b04573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b2891906128ab565b505b8115610bba5760975460995460405163a9059cbb60e01b81526001600160a01b039283169263a9059cbb92610b66929116908690600401612a52565b602060405180830381600087803b158015610b8057600080fd5b505af1158015610b94573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bb891906128ab565b505b8015610c4a5760975460985460405163a9059cbb60e01b81526001600160a01b039283169263a9059cbb92610bf6929116908590600401612a52565b602060405180830381600087803b158015610c1057600080fd5b505af1158015610c24573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c4891906128ab565b505b600081610c578486612ba8565b610c619190612ba8565b90508015610cc857609754604051630852cd8d60e31b8152600481018390526001600160a01b03909116906342966c6890602401600060405180830381600087803b158015610caf57600080fd5b505af1158015610cc3573d6000803e3d6000fd5b505050505b6040518481526001600160a01b038a169033907f2a4031f1dba0999413c3353ef734f98a377ecca64ba5fb8ad571363a468719849060200160405180910390a35091935050505b509392505050565b6000610d2381336104a5565b6001600160a01b0382163b610d4a5760405162461bcd60e51b81526004016104d090612a9e565b609b80546001600160a01b0319166001600160a01b0384161790556040516676657374696e6760c81b815260070161050c565b60c9546000906001600160a01b03163314610dda5760405162461bcd60e51b815260206004820152601860248201527f4d50484d696e7465723a206e6f742076657374696e673032000000000000000060448201526064016104d0565b60975460408051638da5cb5b60e01b8152905130926001600160a01b031691638da5cb5b916004808301926020929190829003018186803b158015610e1e57600080fd5b505afa158015610e32573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e5691906126d8565b6001600160a01b031614610e6c57506000610497565b8115610ef857609754604051631212e5cf60e21b81526001600160a01b039091169063484b973c90610ea49086908690600401612a52565b602060405180830381600087803b158015610ebe57600080fd5b505af1158015610ed2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ef691906128ab565b505b50919050565b600080516020612c52833981519152610f1781336104a5565b60c954609a5460405163a4a6b0c360e01b815233600482018190526001600160a01b0393841693634b0f59da93919289928992899291169063a4a6b0c39060240160206040518083038186803b158015610f7057600080fd5b505afa158015610f84573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fa8919061292b565b6040516001600160e01b031960e088901b1681526001600160a01b03909516600486015267ffffffffffffffff909316602485015260448401919091526064830152608482015260a401600060405180830381600087803b15801561100c57600080fd5b505af1158015611020573d6000803e3d6000fd5b5050505050505050565b600061103681336104a5565b6001600160a01b03821661105c5760405162461bcd60e51b81526004016104d090612ad5565b60975460405163f2fde38b60e01b81526001600160a01b0384811660048301529091169063f2fde38b90602401600060405180830381600087803b1580156110a357600080fd5b505af11580156110b7573d6000803e3d6000fd5b5050505060405161050c906c36b8342a37b5b2b727bbb732b960991b8152600d0190565b60009182526065602090815260408084206001600160a01b0393909316845291905290205460ff1690565b600080516020612c5283398151915261111f81336104a5565b8115806111af575060975460408051638da5cb5b60e01b8152905130926001600160a01b031691638da5cb5b916004808301926020929190829003018186803b15801561116b57600080fd5b505afa15801561117f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111a391906126d8565b6001600160a01b031614155b156111b9576107f9565b609a54604051628b3fe360e21b8152336004820152600091611241916001600160a01b039091169063022cff8c9060240160206040518083038186803b15801561120257600080fd5b505afa158015611216573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061123a919061292b565b84906120e5565b90508061124e57506107f9565b6000336001600160a01b0316635dc05d7f6040518163ffffffff1660e01b815260040160206040518083038186803b15801561128957600080fd5b505afa15801561129d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112c191906126d8565b609754604051631212e5cf60e21b81529192506001600160a01b03169063484b973c906112f49030908690600401612a52565b602060405180830381600087803b15801561130e57600080fd5b505af1158015611322573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061134691906128ab565b50609754604051633950935160e01b81526001600160a01b03909116906339509351906113799084908690600401612a52565b602060405180830381600087803b15801561139357600080fd5b505af11580156113a7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113cb91906128ab565b506097546040516316f6849d60e31b815267ffffffffffffffff871660048201526001600160a01b039182166024820152604481018490529082169063b7b424e890606401600060405180830381600087803b15801561142a57600080fd5b505af115801561143e573d6000803e3d6000fd5b505050505050505050565b6000600080516020612c5283398151915261146481336104a5565b60975460408051638da5cb5b60e01b8152905130926001600160a01b031691638da5cb5b916004808301926020929190829003018186803b1580156114a857600080fd5b505afa1580156114bc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114e091906126d8565b6001600160a01b03161461153857604051600081526001600160a01b0389169033907f8470ffe62d01bbd3da3613a0ca568a59e55b5a5730b74902038057d76b17d85c9060200160405180910390a360009150611a25565b609a5460405163f422eb9160e01b8152336004820152602481018990526044810188905267ffffffffffffffff871660648201528415156084820152600091829182916001600160a01b03169063f422eb919060a40160606040518083038186803b1580156115a657600080fd5b505afa1580156115ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115de9190612943565b9250925092508260001480156115f2575081155b80156115fc575080155b1561160d5760009450505050611a25565b82156118bf57609754604051631212e5cf60e21b81526001600160a01b039091169063484b973c906116459030908790600401612a52565b602060405180830381600087803b15801561165f57600080fd5b505af1158015611673573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061169791906128ab565b50609a5460405163f3eaeb2f60e01b81523360048201526000916001600160a01b03169063f3eaeb2f9060240160206040518083038186803b1580156116dc57600080fd5b505afa1580156116f0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611714919061292b565b9050806117a55760975460405163a9059cbb60e01b81526001600160a01b039091169063a9059cbb9061174d908f908890600401612a52565b602060405180830381600087803b15801561176757600080fd5b505af115801561177b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061179f91906128ab565b506118bd565b609754609b54604051633950935160e01b81526001600160a01b03928316926339509351926117db929116908890600401612a52565b602060405180830381600087803b1580156117f557600080fd5b505af1158015611809573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061182d91906128ab565b50609b546040516302546de160e41b81526001600160a01b038e81166004830152602482018790526044820184905290911690632546de1090606401602060405180830381600087803b15801561188357600080fd5b505af1158015611897573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118bb919061292b565b505b505b811561194f57609754609954604051631212e5cf60e21b81526001600160a01b039283169263484b973c926118fb929116908690600401612a52565b602060405180830381600087803b15801561191557600080fd5b505af1158015611929573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061194d91906128ab565b505b80156119df57609754609854604051631212e5cf60e21b81526001600160a01b039283169263484b973c9261198b929116908590600401612a52565b602060405180830381600087803b1580156119a557600080fd5b505af11580156119b9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119dd91906128ab565b505b6040518381526001600160a01b038c169033907f6814fdc7e44c7ca332752017eb98f9f3c76906682cbcb81cb9a712ad3c87dc719060200160405180910390a350909250505b509695505050505050565b6000600080516020612c52833981519152611a4b81336104a5565b60975460408051638da5cb5b60e01b8152905130926001600160a01b031691638da5cb5b916004808301926020929190829003018186803b158015611a8f57600080fd5b505afa158015611aa3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ac791906126d8565b6001600160a01b031614611b1f57604051600081526001600160a01b0387169033907f8470ffe62d01bbd3da3613a0ca568a59e55b5a5730b74902038057d76b17d85c9060200160405180910390a360009150611ee5565b609a5460405163d2a974db60e01b81523360048201526024810187905260448101869052600091829182916001600160a01b03169063d2a974db9060640160606040518083038186803b158015611b7557600080fd5b505afa158015611b89573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611bad9190612943565b925092509250826000148015611bc1575081155b8015611bcb575080155b15611bdc5760009450505050611ee5565b8215611d7f57609754604051631212e5cf60e21b81526001600160a01b039091169063484b973c90611c149030908790600401612a52565b602060405180830381600087803b158015611c2e57600080fd5b505af1158015611c42573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c6691906128ab565b50609754609b54604051633950935160e01b81526001600160a01b0392831692633950935192611c9d929116908790600401612a52565b602060405180830381600087803b158015611cb757600080fd5b505af1158015611ccb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611cef91906128ab565b50609b546040516302546de160e41b81526001600160a01b038b8116600483015260248201869052604482018a905290911690632546de1090606401602060405180830381600087803b158015611d4557600080fd5b505af1158015611d59573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d7d919061292b565b505b8115611e0f57609754609954604051631212e5cf60e21b81526001600160a01b039283169263484b973c92611dbb929116908690600401612a52565b602060405180830381600087803b158015611dd557600080fd5b505af1158015611de9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e0d91906128ab565b505b8015611e9f57609754609854604051631212e5cf60e21b81526001600160a01b039283169263484b973c92611e4b929116908590600401612a52565b602060405180830381600087803b158015611e6557600080fd5b505af1158015611e79573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e9d91906128ab565b505b6040518381526001600160a01b038a169033907f8470ffe62d01bbd3da3613a0ca568a59e55b5a5730b74902038057d76b17d85c9060200160405180910390a350909250505b50949350505050565b600054610100900460ff1680611f07575060005460ff16155b611f235760405162461bcd60e51b81526004016104d090612b03565b600054610100900460ff16158015611f45576000805461ffff19166101011790555b611f5387878787878761210b565b8015611f65576000805461ff00191690555b50505050505050565b600082815260656020526040902060010154611f8a81336104a5565b6107f9838361207e565b611f9e82826110db565b61087857611fb6816001600160a01b03166014612178565b611fc1836020612178565b604051602001611fd29291906129dd565b60408051601f198184030181529082905262461bcd60e51b82526104d091600401612a6b565b61200282826110db565b6108785760008281526065602090815260408083206001600160a01b03851684529091529020805460ff1916600117905561203a3390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b61208882826110db565b156108785760008281526065602090815260408083206001600160a01b0385168085529252808320805460ff1916905551339285917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45050565b6000670de0b6b3a76400006120fa8385612b89565b6121049190612b69565b9392505050565b600054610100900460ff1680612124575060005460ff16155b6121405760405162461bcd60e51b81526004016104d090612b03565b600054610100900460ff16158015612162576000805461ffff19166101011790555b61216f878787878761235a565b611f53826123e0565b60606000612187836002612b89565b612192906002612b51565b67ffffffffffffffff8111156121b857634e487b7160e01b600052604160045260246000fd5b6040519080825280601f01601f1916602001820160405280156121e2576020820181803683370190505b509050600360fc1b8160008151811061220b57634e487b7160e01b600052603260045260246000fd5b60200101906001600160f81b031916908160001a905350600f60fb1b8160018151811061224857634e487b7160e01b600052603260045260246000fd5b60200101906001600160f81b031916908160001a905350600061226c846002612b89565b612277906001612b51565b90505b600181111561230b576f181899199a1a9b1b9c1cb0b131b232b360811b85600f16601081106122b957634e487b7160e01b600052603260045260246000fd5b1a60f81b8282815181106122dd57634e487b7160e01b600052603260045260246000fd5b60200101906001600160f81b031916908160001a90535060049490941c9361230481612beb565b905061227a565b5083156121045760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e7460448201526064016104d0565b600054610100900460ff1680612373575060005460ff16155b61238f5760405162461bcd60e51b81526004016104d090612b03565b600054610100900460ff161580156123b1576000805461ffff19166101011790555b6123b9612467565b6123c686868686866124eb565b80156123d8576000805461ff00191690555b505050505050565b600054610100900460ff16806123f9575060005460ff16155b6124155760405162461bcd60e51b81526004016104d090612b03565b600054610100900460ff16158015612437576000805461ffff19166101011790555b60c980546001600160a01b0319166001600160a01b0384161790558015610878576000805461ff00191690555050565b600054610100900460ff1680612480575060005460ff16155b61249c5760405162461bcd60e51b81526004016104d090612b03565b600054610100900460ff161580156124be576000805461ffff19166101011790555b6124c66125f4565b6124ce6125f4565b6124d66125f4565b80156124e8576000805461ff00191690555b50565b600054610100900460ff1680612504575060005460ff16155b6125205760405162461bcd60e51b81526004016104d090612b03565b600054610100900460ff16158015612542576000805461ffff19166101011790555b61254d60003361265e565b612585600080516020612c528339815191527f8619cecd8b9e095ab43867f5b69d492180450fe862e6b50bfbfb24b75dd84c8a612668565b609780546001600160a01b03199081166001600160a01b0389811691909117909255609880548216888416179055609980548216878416179055609a80548216868416179055609b805490911691841691909117905580156123d8576000805461ff0019169055505050505050565b600054610100900460ff168061260d575060005460ff16155b6126295760405162461bcd60e51b81526004016104d090612b03565b600054610100900460ff161580156124d6576000805461ffff191661010117905580156124e8576000805461ff001916905550565b6108788282611ff8565b600082815260656020526040902060010154819060405184907fbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff90600090a460009182526065602052604090912060010155565b6000602082840312156126cd578081fd5b813561210481612c18565b6000602082840312156126e9578081fd5b815161210481612c18565b60008060008060008060c0878903121561270c578182fd5b863561271781612c18565b9550602087013561272781612c18565b9450604087013561273781612c18565b9350606087013561274781612c18565b9250608087013561275781612c18565b915060a087013561276781612c18565b809150509295509295509295565b60008060408385031215612787578182fd5b823561279281612c18565b946020939093013593505050565b6000806000606084860312156127b4578283fd5b83356127bf81612c18565b92506020840135915060408401356127d681612c2d565b809150509250925092565b600080600080608085870312156127f6578384fd5b843561280181612c18565b966020860135965060408601359560600135945092505050565b60008060008060008060c08789031215612833578182fd5b863561283e81612c18565b95506020870135945060408701359350606087013561285c81612c3b565b92506080870135915060a087013561276781612c2d565b60008060408385031215612885578182fd5b823561289081612c18565b915060208301356128a081612c3b565b809150509250929050565b6000602082840312156128bc578081fd5b815161210481612c2d565b6000602082840312156128d8578081fd5b5035919050565b600080604083850312156128f1578081fd5b8235915060208301356128a081612c18565b600060208284031215612914578081fd5b81356001600160e01b031981168114612104578182fd5b60006020828403121561293c578081fd5b5051919050565b600080600060608486031215612957578081fd5b8351925060208401519150604084015190509250925092565b600060208284031215612981578081fd5b815161210481612c3b565b6000806040838503121561299e578182fd5b823561279281612c3b565b6000806000606084860312156129bd578081fd5b83356129c881612c3b565b95602085013595506040909401359392505050565b60007f416363657373436f6e74726f6c3a206163636f756e742000000000000000000082528351612a15816017850160208801612bbf565b7001034b99036b4b9b9b4b733903937b6329607d1b6017918401918201528351612a46816028840160208801612bbf565b01602801949350505050565b6001600160a01b03929092168252602082015260400190565b6000602082528251806020840152612a8a816040850160208701612bbf565b601f01601f19169190910160400192915050565b60208082526017908201527f4d50484d696e7465723a206e6f7420636f6e7472616374000000000000000000604082015260600190565b6020808252601490820152734d50484d696e7465723a2030206164647265737360601b604082015260600190565b6020808252602e908201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160408201526d191e481a5b9a5d1a585b1a5e995960921b606082015260800190565b60008219821115612b6457612b64612c02565b500190565b600082612b8457634e487b7160e01b81526012600452602481fd5b500490565b6000816000190483118215151615612ba357612ba3612c02565b500290565b600082821015612bba57612bba612c02565b500390565b60005b83811015612bda578181015183820152602001612bc2565b838111156106925750506000910152565b600081612bfa57612bfa612c02565b506000190190565b634e487b7160e01b600052601160045260246000fd5b6001600160a01b03811681146124e857600080fd5b80151581146124e857600080fd5b67ffffffffffffffff811681146124e857600080fdfe01929b51ccb866359f22f5a3ce5c78c9fc36c4de9719e0e678f9a41b4e88b733a2646970667358221220e729d3f6f714735593b0b959cc7d860e3f7d3728ff70f4e31010dede4cb1a1d564736f6c63430008030033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "getRoleAdmin(bytes32)": {
        "details": "Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."
      },
      "grantRole(bytes32,address)": {
        "details": "Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."
      },
      "hasRole(bytes32,address)": {
        "details": "Returns `true` if `account` has been granted `role`."
      },
      "mintDepositorReward(address,uint256,uint256,uint256)": {
        "params": {
          "depositAmount": "The deposit amount in the pool's stablecoins",
          "depositPeriodInSeconds": "The deposit's lock period in seconds",
          "interestAmount": "The deposit's fixed-rate interest amount in the pool's stablecoins",
          "to": "The depositor"
        },
        "returns": {
          "_0": "depositorReward The MPH amount to mint to the depositor"
        }
      },
      "mintFunderReward(address,uint256,uint256,uint64,uint256,bool)": {
        "params": {
          "depositAmount": "The deposit amount in the pool's stablecoins",
          "early": "True if the deposit is withdrawn early, false if the deposit is mature",
          "fundingCreationTimestamp": "The timestamp of the funding's creation, in seconds",
          "interestPayoutAmount": "The interest payout amount to the funder, in the pool's stablecoins. Includes the interest from other funded deposits.",
          "maturationTimestamp": "The maturation timestamp of the deposit, in seconds",
          "to": "The funder"
        },
        "returns": {
          "_0": "funderReward The MPH amount to mint to the funder"
        }
      },
      "renounceRole(bytes32,address)": {
        "details": "Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."
      },
      "revokeRole(bytes32,address)": {
        "details": "Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."
      },
      "supportsInterface(bytes4)": {
        "details": "See {IERC165-supportsInterface}."
      },
      "takeBackDepositorReward(address,uint256,bool)": {
        "params": {
          "early": "True if the deposit is withdrawn early, false if the deposit is mature",
          "from": "The depositor",
          "mintMPHAmount": "The MPH amount originally minted to the depositor as reward"
        },
        "returns": {
          "_0": "takeBackAmount The MPH amount to take back from the depositor"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "createVestForDeposit(address,uint64)": {
        "notice": "v3 functions"
      },
      "mintDepositorReward(address,uint256,uint256,uint256)": {
        "notice": "Mints the MPH reward to a depositor upon deposit."
      },
      "mintFunderReward(address,uint256,uint256,uint64,uint256,bool)": {
        "notice": "Mints the MPH reward to a deficit funder upon withdrawal of an underlying deposit."
      },
      "mph()": {
        "notice": "External contracts"
      },
      "setGovTreasury(address)": {
        "notice": "Param setters"
      },
      "setVesting02(address)": {
        "notice": "Param setters"
      },
      "takeBackDepositorReward(address,uint256,bool)": {
        "notice": "Takes back MPH from depositor upon withdrawal. If takeBackAmount > devReward + govReward, the extra MPH should be burnt."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 612,
        "contract": "contracts/rewards/MPHMinter.sol:MPHMinter",
        "label": "_initialized",
        "offset": 0,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 615,
        "contract": "contracts/rewards/MPHMinter.sol:MPHMinter",
        "label": "_initializing",
        "offset": 1,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 3064,
        "contract": "contracts/rewards/MPHMinter.sol:MPHMinter",
        "label": "__gap",
        "offset": 0,
        "slot": "1",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 3453,
        "contract": "contracts/rewards/MPHMinter.sol:MPHMinter",
        "label": "__gap",
        "offset": 0,
        "slot": "51",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 86,
        "contract": "contracts/rewards/MPHMinter.sol:MPHMinter",
        "label": "_roles",
        "offset": 0,
        "slot": "101",
        "type": "t_mapping(t_bytes32,t_struct(RoleData)81_storage)"
      },
      {
        "astId": 394,
        "contract": "contracts/rewards/MPHMinter.sol:MPHMinter",
        "label": "__gap",
        "offset": 0,
        "slot": "102",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 19440,
        "contract": "contracts/rewards/MPHMinter.sol:MPHMinter",
        "label": "mph",
        "offset": 0,
        "slot": "151",
        "type": "t_contract(MPHToken)20170"
      },
      {
        "astId": 19442,
        "contract": "contracts/rewards/MPHMinter.sol:MPHMinter",
        "label": "govTreasury",
        "offset": 0,
        "slot": "152",
        "type": "t_address"
      },
      {
        "astId": 19444,
        "contract": "contracts/rewards/MPHMinter.sol:MPHMinter",
        "label": "devWallet",
        "offset": 0,
        "slot": "153",
        "type": "t_address"
      },
      {
        "astId": 19447,
        "contract": "contracts/rewards/MPHMinter.sol:MPHMinter",
        "label": "issuanceModel",
        "offset": 0,
        "slot": "154",
        "type": "t_contract(IMPHIssuanceModel)16339"
      },
      {
        "astId": 19450,
        "contract": "contracts/rewards/MPHMinter.sol:MPHMinter",
        "label": "vesting",
        "offset": 0,
        "slot": "155",
        "type": "t_contract(Vesting)20396"
      },
      {
        "astId": 20118,
        "contract": "contracts/rewards/MPHMinter.sol:MPHMinter",
        "label": "__gap",
        "offset": 0,
        "slot": "156",
        "type": "t_array(t_uint256)45_storage"
      },
      {
        "astId": 19084,
        "contract": "contracts/rewards/MPHMinter.sol:MPHMinter",
        "label": "vesting02",
        "offset": 0,
        "slot": "201",
        "type": "t_contract(Vesting02)21037"
      },
      {
        "astId": 19374,
        "contract": "contracts/rewards/MPHMinter.sol:MPHMinter",
        "label": "__gap",
        "offset": 0,
        "slot": "202",
        "type": "t_array(t_uint256)49_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)45_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[45]",
        "numberOfBytes": "1440"
      },
      "t_array(t_uint256)49_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[49]",
        "numberOfBytes": "1568"
      },
      "t_array(t_uint256)50_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[50]",
        "numberOfBytes": "1600"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(IMPHIssuanceModel)16339": {
        "encoding": "inplace",
        "label": "contract IMPHIssuanceModel",
        "numberOfBytes": "20"
      },
      "t_contract(MPHToken)20170": {
        "encoding": "inplace",
        "label": "contract MPHToken",
        "numberOfBytes": "20"
      },
      "t_contract(Vesting)20396": {
        "encoding": "inplace",
        "label": "contract Vesting",
        "numberOfBytes": "20"
      },
      "t_contract(Vesting02)21037": {
        "encoding": "inplace",
        "label": "contract Vesting02",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_bytes32,t_struct(RoleData)81_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct AccessControlUpgradeable.RoleData)",
        "numberOfBytes": "32",
        "value": "t_struct(RoleData)81_storage"
      },
      "t_struct(RoleData)81_storage": {
        "encoding": "inplace",
        "label": "struct AccessControlUpgradeable.RoleData",
        "members": [
          {
            "astId": 78,
            "contract": "contracts/rewards/MPHMinter.sol:MPHMinter",
            "label": "members",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_address,t_bool)"
          },
          {
            "astId": 80,
            "contract": "contracts/rewards/MPHMinter.sol:MPHMinter",
            "label": "adminRole",
            "offset": 0,
            "slot": "1",
            "type": "t_bytes32"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}
